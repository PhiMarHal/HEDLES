<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>HEDLES</title>

    <!-- Favicon -->
    <link rel="icon" type="image/png" href="assets/bat_icon.png">

    <!-- Google Fonts - Press Start 2P with fallback to local -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">

    <script src="https://cdnjs.cloudflare.com/ajax/libs/phaser/3.70.0/phaser.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100vh;
            background: #000000;
            font-family: monospace;
            touch-action: none;
            overflow: hidden;
            position: fixed;
            top: 0;
            left: 0;
        }

        html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
        }
    </style>
</head>

<body>
    <div id="game-container"></div>

    <script>
        const BASE_URL = 'https://hedles.loiyaa.com/';

        // ======================================
        // MINIMAL SHARED UTILITIES (Only genuinely duplicated code)
        // ======================================

        class SharedUtils {
            // Shared button press animation (was identical across scenes)
            static buttonPress(scene, button, pressedTexture, targetScene) {
                if (scene.cache.audio.exists('tap_button')) {
                    scene.sound.play('tap_button');
                }

                const originalTexture = button.texture.key;
                button.setTexture(pressedTexture);

                scene.time.delayedCall(150, () => {
                    button.setTexture(originalTexture);
                    scene.time.delayedCall(50, () => {
                        if (typeof targetScene === 'function') {
                            targetScene();
                        } else {
                            scene.scene.start(targetScene);
                        }
                    });
                });
            }

            // Shared layout calculations (exact same math in Start/Story scenes)
            static getBookLayout() {
                const gameWidth = 900;
                const gameHeight = 1600;
                const centerX = gameWidth / 2;
                const bookScale = gameWidth / 1024; // 0.878
                const scaledBookHeight = 1220 * bookScale; // 1071px
                const bookY = gameHeight / 2;
                const buttonSpacing = (gameHeight - scaledBookHeight) / 2; // 264px
                const bottomButtonY = gameHeight - (buttonSpacing / 2);

                return {
                    gameWidth,
                    gameHeight,
                    centerX,
                    bookScale,
                    scaledBookHeight,
                    bookY,
                    bottomButtonY,
                    storyButtonX: gameWidth * 0.25,
                    playButtonX: gameWidth * 0.75
                };
            }

            // Shared text wrapping (duplicated between Story and Game Over)
            static wrapText(text, fontFamily, fontSize, maxWidth, scene) {
                const words = text.split(' ');
                const lines = [];
                let currentLine = '';

                const measureText = scene.add.text(0, 0, '', {
                    fontFamily: fontFamily,
                    fontSize: fontSize
                });

                for (let i = 0; i < words.length; i++) {
                    const word = words[i];
                    const testLine = currentLine ? `${currentLine} ${word}` : word;

                    measureText.setText(testLine);
                    const lineWidth = measureText.width;

                    if (lineWidth <= maxWidth || currentLine === '') {
                        currentLine = testLine;
                    } else {
                        lines.push(currentLine);
                        currentLine = word;
                    }
                }

                if (currentLine) {
                    lines.push(currentLine);
                }

                measureText.destroy();
                return lines.join('\n');
            }
        }

        // Start Screen Scene
        class StartScreen extends Phaser.Scene {
            constructor() {
                super({ key: 'StartScreen' });
            }

            preload() {
                // Load start screen assets
                this.load.image('cover_hedles', BASE_URL + 'assets/cover_hedles.jpg');
                this.load.image('click_story', BASE_URL + 'assets/click_story.png');
                this.load.image('click_story2', BASE_URL + 'assets/click_story2.png');
                this.load.image('click_play', BASE_URL + 'assets/click_play.png');
                this.load.image('click_play2', BASE_URL + 'assets/click_play2.png');
                this.load.audio('tap_button', BASE_URL + 'assets/tap_button.mp3');
            }

            create() {
                this.cameras.main.setBackgroundColor(0x000000);

                const layout = SharedUtils.getBookLayout();

                // Add cover image (scaled to fit canvas width)
                this.cover = this.add.image(layout.centerX, layout.bookY, 'cover_hedles');
                this.cover.setDisplaySize(layout.gameWidth, layout.scaledBookHeight);

                // Story button (bottom left)
                this.storyButton = this.add.image(layout.storyButtonX, layout.bottomButtonY, 'click_story');
                this.storyButton.setDisplaySize(384, 192);
                this.storyButton.setInteractive();
                this.storyButton.on('pointerover', () => {
                    this.storyButton.setTint(0xcccccc);
                });
                this.storyButton.on('pointerout', () => {
                    this.storyButton.setTint(0xffffff);
                });
                this.storyButton.on('pointerdown', () => {
                    SharedUtils.buttonPress(this, this.storyButton, 'click_story2', 'StoryScreen');
                });

                // Play button (bottom right)
                this.playButton = this.add.image(layout.playButtonX, layout.bottomButtonY, 'click_play');
                this.playButton.setDisplaySize(384, 192);
                this.playButton.setInteractive();
                this.playButton.on('pointerover', () => {
                    this.playButton.setTint(0xcccccc);
                });
                this.playButton.on('pointerout', () => {
                    this.playButton.setTint(0xffffff);
                });
                this.playButton.on('pointerdown', () => {
                    SharedUtils.buttonPress(this, this.playButton, 'click_play2', 'GameScreen');
                });

                // Keyboard support
                this.enterKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.ENTER);
                this.enterKey.on('down', () => {
                    SharedUtils.buttonPress(this, this.playButton, 'click_play2', 'GameScreen');
                });
            }
        }

        // Story Screen Scene
        class StoryScreen extends Phaser.Scene {
            constructor() {
                super({ key: 'StoryScreen' });
                this.gameWidth = 900;
                this.gameHeight = 1600;

                // Story text (themed around the game)
                this.storyLines = [
                    "Behold, the realm of Forgotten Runes. A world filled with magic and wonders.",
                    "One mystery lies above all. Shrouded in a tower whose name was lost to time.",
                    "Nobody knows what goes on in the Secret Tower.",
                    "Nobody, except the Apprentice.",
                    "Every full moon, a new Apprentice is chosen. They set out for the tower. They're never to be seen again.",
                    "Today, you are the chosen Apprentice.",
                    "The doors of the Secret Tower open in front of you.",
                    "As you step inside, runes float in front of your eyes. They spell the truth of this place.",
                    "Wizards are not born. They are made.",
                    "All begins with the Donkeyhorse.",
                    "This magical beast roams the tower halls, laying eggs as it does.",
                    "The eggs hatch into bodies, without heads. Without souls. Mindless creatures, called Hedles.",
                    "As the Apprentice, your role is to attach heads to the Hedles.",
                    "Thus, a Wizard is born.",
                    "The Hedles grow fast. To keep up with them, you must use the Headcannon.",
                    "Aim true, Apprentice. The future of all wizardy relies on you."
                ];

                this.currentLineIndex = 0;
                this.isTyping = false;
                this.canAdvance = false;
                this.typewriterSpeed = 50;
                this.typewriterSounds = [];
                this.fontLoaded = false;
            }

            preload() {
                // Load story assets
                this.load.image('cover_secret', BASE_URL + 'assets/cover_secret.jpg');
                this.load.image('text_background', BASE_URL + 'assets/text_background.png');
                this.load.image('click_story', BASE_URL + 'assets/click_story.png');
                this.load.image('click_story2', BASE_URL + 'assets/click_story2.png');
                this.load.image('click_play', BASE_URL + 'assets/click_play.png');
                this.load.image('click_play2', BASE_URL + 'assets/click_play2.png');
                this.load.audio('tap_button', BASE_URL + 'assets/tap_button.mp3');

                // Load typewriter sounds
                this.load.audio('type_blip1', BASE_URL + 'assets/type_blip1.mp3');
                this.load.audio('type_blip2', BASE_URL + 'assets/type_blip2.mp3');
                this.load.audio('type_blip3', BASE_URL + 'assets/type_blip3.mp3');

                // KEEP the sophisticated font loading system - it's necessary!
                this.load.addListener('complete', () => {
                    console.log('Assets loaded, now waiting for Google Fonts...');

                    const forceLoadFont = () => {
                        const testElement = document.createElement('div');
                        testElement.style.fontFamily = '"Press Start 2P", monospace';
                        testElement.style.fontSize = '24px';
                        testElement.style.position = 'absolute';
                        testElement.style.visibility = 'hidden';
                        testElement.style.left = '-9999px';
                        testElement.textContent = 'Test font loading';
                        document.body.appendChild(testElement);

                        document.fonts.ready.then(() => {
                            console.log('Fonts ready, forcing render...');

                            setTimeout(() => {
                                const fontLoaded = document.fonts.check('24px "Press Start 2P"');
                                console.log('Press Start 2P available:', fontLoaded);

                                this.fontLoaded = fontLoaded;
                                document.body.removeChild(testElement);
                                this.createStoryElements();

                            }, 50);

                        }).catch((error) => {
                            console.error('Font loading failed:', error);
                            document.body.removeChild(testElement);
                            this.fontLoaded = false;
                            this.createStoryElements();
                        });
                    };

                    forceLoadFont();
                });

                // Error handlers
                this.load.on('loaderror', (file) => {
                    console.warn('Missing story asset:', file.key);
                    const graphics = this.make.graphics({ x: 0, y: 0, add: false });

                    if (file.key === 'cover_secret') {
                        graphics.fillStyle(0x1a1a2e, 1);
                        graphics.fillRect(0, 0, 1024, 1220);
                        graphics.fillStyle(0x666666, 1);
                        graphics.fillRect(400, 600, 224, 50);
                        graphics.generateTexture('cover_secret', 1024, 1220);
                    } else if (file.key === 'text_background') {
                        graphics.fillStyle(0x2c1810, 1);
                        graphics.fillRect(0, 0, 1024, 256);
                        graphics.lineStyle(4, 0x8b4513);
                        graphics.strokeRect(8, 8, 1008, 240);
                        graphics.generateTexture('text_background', 1024, 256);
                    } else if (file.key.startsWith('click_story') || file.key.startsWith('click_play')) {
                        const isGolden = file.key.includes('2');
                        graphics.fillStyle(0x444444, 1);
                        graphics.fillRect(0, 0, 512, 256);
                        graphics.fillStyle(isGolden ? 0xFFD700 : 0xffffff, 1);
                        graphics.fillRect(20, 50, 472, 156);
                        graphics.generateTexture(file.key, 512, 256);
                    }

                    graphics.destroy();
                });
            }

            create() {
                this.cameras.main.setBackgroundColor(0x000000);
                // Wait for font loading to complete before creating elements
            }

            createStoryElements() {
                const layout = SharedUtils.getBookLayout();

                // Add secret cover image (same scaling)
                this.cover = this.add.image(layout.centerX, layout.bookY, 'cover_secret');
                this.cover.setDisplaySize(layout.gameWidth, layout.scaledBookHeight);

                // Story button (bottom left)
                this.storyButton = this.add.image(layout.storyButtonX, layout.bottomButtonY, 'click_story');
                this.storyButton.setDisplaySize(384, 192);
                this.storyButton.setInteractive();
                this.storyButton.on('pointerover', () => {
                    this.storyButton.setTint(0xcccccc);
                });
                this.storyButton.on('pointerout', () => {
                    this.storyButton.setTint(0xffffff);
                });
                this.storyButton.on('pointerdown', () => {
                    SharedUtils.buttonPress(this, this.storyButton, 'click_story2', 'StoryScreen');
                });

                // Play button (bottom right)
                this.playButton = this.add.image(layout.playButtonX, layout.bottomButtonY, 'click_play');
                this.playButton.setDisplaySize(384, 192);
                this.playButton.setInteractive();
                this.playButton.on('pointerover', () => {
                    this.playButton.setTint(0xcccccc);
                });
                this.playButton.on('pointerout', () => {
                    this.playButton.setTint(0xffffff);
                });
                this.playButton.on('pointerdown', () => {
                    SharedUtils.buttonPress(this, this.playButton, 'click_play2', 'GameScreen');
                });

                // Add text background INSIDE the cover area (bottom portion)
                const textBgScale = layout.bookScale; // Same scale as book
                const textBgWidth = 1024 * textBgScale; // Scaled width
                const textBgHeight = 256 * textBgScale; // Scaled height
                const textBgY = layout.bookY + (layout.scaledBookHeight / 2) - (textBgHeight / 2) - 50; // Inside bottom of book

                this.textBackground = this.add.image(layout.centerX, textBgY, 'text_background');
                this.textBackground.setDisplaySize(textBgWidth, textBgHeight);

                // Create text object for story
                const textMarginX = textBgWidth * 0.08;
                const textMarginY = textBgHeight * 0.22;
                this.textWrapWidth = textBgWidth - (textMarginX * 2);

                const fontFamily = '"Press Start 2P", "Press Start 2P Local", monospace';
                const fontSize = this.fontLoaded ? '24px' : '28px';

                console.log('Creating text with font stack:', fontFamily, 'size:', fontSize);

                this.storyText = this.add.text(
                    layout.centerX - (textBgWidth / 2) + textMarginX,
                    textBgY - (textBgHeight / 2) + textMarginY,
                    '',
                    {
                        fontFamily: fontFamily,
                        fontSize: fontSize,
                        fill: '#ffffff',
                        align: 'left',
                        wordWrap: { width: this.textWrapWidth, useAdvancedWrap: true },
                        lineSpacing: 8
                    }
                );
                this.storyText.setOrigin(0, 0);

                // Add continue prompt (initially hidden)
                this.continuePrompt = this.add.text(layout.centerX, textBgY + (textBgHeight / 2) + 40, 'Press SPACE or CLICK to continue...', {
                    fontFamily: '"Press Start 2P", "Press Start 2P Local", monospace',
                    fontSize: this.fontLoaded ? '18px' : '20px',
                    fill: '#888888',
                    align: 'center'
                });
                this.continuePrompt.setOrigin(0.5);
                this.continuePrompt.setVisible(false);

                // Blinking effect for continue prompt
                this.tweens.add({
                    targets: this.continuePrompt,
                    alpha: 0.3,
                    duration: 800,
                    yoyo: true,
                    repeat: -1,
                    ease: 'Sine.easeInOut'
                });

                // Collect available typewriter sounds
                this.typewriterSounds = [];
                for (let i = 1; i <= 3; i++) {
                    if (this.cache.audio.exists(`type_blip${i}`)) {
                        this.typewriterSounds.push(`type_blip${i}`);
                    }
                }

                // Input handling
                this.input.on('pointerdown', () => {
                    this.handleAdvance();
                });

                this.spaceKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);
                this.spaceKey.on('down', () => {
                    this.handleAdvance();
                });

                this.escapeKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.ESC);
                this.escapeKey.on('down', () => {
                    this.scene.start('StartScreen');
                });

                // Start the first line
                this.showNextLine();
            }

            handleAdvance() {
                if (this.isTyping) {
                    this.completeCurrentLine();
                } else if (this.canAdvance) {
                    this.currentLineIndex++;
                    if (this.currentLineIndex >= this.storyLines.length) {
                        SharedUtils.buttonPress(this, this.playButton, 'click_play2', 'GameScreen');
                    } else {
                        this.showNextLine();
                    }
                }
            }

            showNextLine() {
                if (this.currentLineIndex >= this.storyLines.length) return;

                this.isTyping = true;
                this.canAdvance = false;
                this.continuePrompt.setVisible(false);

                const fullText = this.storyLines[this.currentLineIndex];

                // Use shared text wrapping utility
                const wrappedText = SharedUtils.wrapText(
                    fullText,
                    this.storyText.style.fontFamily,
                    this.storyText.style.fontSize,
                    this.textWrapWidth,
                    this
                );

                this.currentWrappedText = wrappedText;
                this.storyText.setWordWrapWidth(0);

                // Now type the pre-wrapped text character by character
                let currentText = '';
                let charIndex = 0;

                this.storyText.setText('');

                const typeNextChar = () => {
                    if (charIndex < wrappedText.length && this.isTyping) {
                        currentText += wrappedText[charIndex];
                        this.storyText.setText(currentText);

                        if (wrappedText[charIndex] !== ' ' && wrappedText[charIndex] !== '\n' && this.typewriterSounds.length > 0) {
                            const randomSound = Phaser.Utils.Array.GetRandom(this.typewriterSounds);
                            this.sound.play(randomSound, { volume: 0.3 });
                        }

                        charIndex++;
                        this.time.delayedCall(this.typewriterSpeed, typeNextChar);
                    } else {
                        this.completeCurrentLine();
                    }
                };

                typeNextChar();
            }

            completeCurrentLine() {
                this.isTyping = false;
                this.canAdvance = true;
                this.storyText.setText(this.currentWrappedText);
                this.continuePrompt.setVisible(true);
            }
        }

        // Game Screen Scene - KEEP ALL FUNCTIONALITY INTACT!
        class GameScreen extends Phaser.Scene {
            constructor() {
                super({ key: 'GameScreen' });

                // Game configuration - KEEP ALL EXACTLY AS THEY WERE
                this.CANNON_SIZE = 96;
                this.CANNON_CHARGE_TIME = 500;
                this.CANNON_COOLDOWN_TIME = 1000;
                this.HEAD_SIZE = 128;
                this.HEDLE_SIZE = 160;
                this.EGG_SIZE = 80;
                this.HEAD_SPEED = 800;
                this.HEDLE_SPEED = 100;
                this.HEDLE_MOVE_TIME = 2000;
                this.HEDLE_WAIT_TIME = 1000;
                this.HEDLE_WALK_SPRITE_INTERVAL = 400;
                this.MINIMUM_SPAWN_DELAY = 500;
                this.EGG_GROWTH_TIME = 4000;
                this.MIN_HEAD_DAMAGE_SPEED = 50;
                this.BAT_SPEED = 200;
                this.SPELL_SLOT_SIZE = 120;
                this.FIRE_EXPLOSION_RADIUS = 250;
                this.WATER_LINE_LENGTH = 3200;
                this.MULTI_SHOT_COUNT = 8;
                this.MULTI_SHOT_DELAY = 250;

                // Horse configuration
                this.HORSE_SIZE = 120;
                this.HORSE_SPEED = 150;
                this.HORSE_WALK_FRAME_DURATION = 200;
                this.HORSE_LAY_FRAME_DURATION = 200;

                // Sprite counts
                this.HEAD_COUNT = 119;
                this.HEDLE_COUNT = 84;

                // Game dimensions
                this.gameWidth = 900;
                this.gameHeight = 1600;
            }

            init() {
                // Reset all game state on init (for proper restart) - KEEP ALL OF THIS
                this.score = 0;
                this.gameOver = false;
                this.cannonAngle = -Math.PI / 2;
                this.cannonCharging = false;
                this.cannonOnCooldown = false;
                this.cannonChargeStart = 0;
                this.cannonCooldownStart = 0;
                this.lastPointerPosition = { x: 450, y: 400 };
                this.currentSpawnDelay = 4000;
                this.spawnSpeedMultiplier = 0.96;
                this.currentBatDelay = 8000;
                this.batDelayIncrement = 200;
                this.spellSlots = [null, null, null, null];
                this.selectedSpell = null;
                this.isMultiShotting = false;
                this.isFiring = false;
                this.shotQueued = false;
                this.uiClickThisFrame = false;
                this.scoreDigits = [];
                this.DIGIT_SIZE = 96;
                this.gameOverFadeOverlay = null;
                this.currentFadeOpacity = 0;
                this.targetFadeOpacity = 0;
                this.fadeTransitionSpeed = 1.0;
                this.fadeUpdateCounter = 0;

                // Game over state
                this.gameOverMessage = null;
                this.gameOverPlayButton = null;
                this.fontLoaded = false;
                this.typewriterSounds = [];
                this.gameOverMessages = [
                    "The darkness engulfs you...",
                    "As you lose consciousness, odd runes twirl around your head: KA JI SU LI"
                ];

                // Horse state - CRITICAL: Keep all horse state exactly as it was!
                this.horse = null;
                this.horseWalkFrame = 0;
                this.horseIsLaying = false;
                this.horseAngle = 0;
                this.horseVelocityX = 0;
                this.horseVelocityY = 0;
                this.pendingEggSpawn = false;

                // Loading state
                this.loadingText = null;
                this.loadingTween = null;

                // Show loading message immediately when scene starts
                this.showLoadingMessage();
            }

            preload() {
                // Load ALL game assets exactly as before
                this.load.image('cannon', BASE_URL + 'assets/cannon.png');
                this.load.audio('cannon_shot', BASE_URL + 'assets/cannon_shot.mp3');
                this.load.audio('hedles_music', BASE_URL + 'assets/HEDLES.mp3');
                this.load.image('click_play', BASE_URL + 'assets/click_play.png');
                this.load.image('click_play2', BASE_URL + 'assets/click_play2.png');
                this.load.audio('tap_button', BASE_URL + 'assets/tap_button.mp3');
                this.load.audio('type_blip1', BASE_URL + 'assets/type_blip1.mp3');
                this.load.audio('type_blip2', BASE_URL + 'assets/type_blip2.mp3');
                this.load.audio('type_blip3', BASE_URL + 'assets/type_blip3.mp3');
                this.load.image('background', BASE_URL + 'assets/background.png');
                this.load.audio('oww_1', BASE_URL + 'assets/oww_1.mp3');
                this.load.audio('oww_2', BASE_URL + 'assets/oww_2.mp3');
                this.load.audio('oww_3', BASE_URL + 'assets/oww_3.mp3');
                this.load.audio('oww_4', BASE_URL + 'assets/oww_4.mp3');
                this.load.audio('pickup_spell', BASE_URL + 'assets/pickup_spell.mp3');
                this.load.audio('ball_bounce', BASE_URL + 'assets/ball_bounce.mp3');
                this.load.image('egg', BASE_URL + 'assets/item_egg.png');

                // Load bat animation sprites
                this.load.image('bat_1', BASE_URL + 'assets/bat_1.png');
                this.load.image('bat_2', BASE_URL + 'assets/bat_2.png');
                this.load.image('bat_3', BASE_URL + 'assets/bat_3.png');
                this.load.image('bat_4', BASE_URL + 'assets/bat_4.png');

                // Load book sprites
                this.load.image('tome_fire', BASE_URL + 'assets/tome_fire.png');
                this.load.image('tome_water', BASE_URL + 'assets/tome_water.png');
                this.load.image('tome_storm', BASE_URL + 'assets/tome_storm.png');
                this.load.image('tome_multi', BASE_URL + 'assets/tome_multi.png');

                // Load spell interface icons
                this.load.image('icon_blank', BASE_URL + 'assets/icon_blank.png');
                this.load.image('icon_fire', BASE_URL + 'assets/icon_fire.png');
                this.load.image('icon_water', BASE_URL + 'assets/icon_water.png');
                this.load.image('icon_storm', BASE_URL + 'assets/icon_storm.png');
                this.load.image('icon_multi', BASE_URL + 'assets/icon_multi.png');

                // Load spell effect sprites
                this.load.image('spell_fire', BASE_URL + 'assets/spell_fire.png');
                this.load.image('spell_water', BASE_URL + 'assets/spell_water.png');
                this.load.image('spell_storm', BASE_URL + 'assets/spell_storm.png');
                this.load.image('spell_multi', BASE_URL + 'assets/spell_multi.png');

                // Load digit sprites for score
                for (let i = 0; i <= 9; i++) {
                    this.load.image(`digit_${i}`, BASE_URL + `assets/digit_${i}.png`);
                }

                // Load horse sprites
                for (let i = 1; i <= 8; i++) {
                    this.load.image(`horse_walk_${i}`, BASE_URL + `assets/horse_walk_${i}.png`);
                }

                for (let i = 1; i <= 3; i++) {
                    this.load.image(`horse_egg_${i}`, BASE_URL + `assets/horse_egg_${i}.png`);
                }

                // KEEP the sophisticated font loading system
                this.load.addListener('complete', () => {
                    console.log('Game assets loaded, font should be available from Google Fonts...');
                    this.fontLoaded = true;
                });

                this.load.addListener('complete', () => {
                    this.typewriterSounds = [];
                    for (let i = 1; i <= 3; i++) {
                        if (this.cache.audio.exists(`type_blip${i}`)) {
                            this.typewriterSounds.push(`type_blip${i}`);
                        }
                    }
                });

                // Load head sprites
                for (let i = 1; i <= this.HEAD_COUNT; i++) {
                    const num = i.toString().padStart(4, '0');
                    this.load.image(`head_${num}`, BASE_URL + `assets/head_${num}_ft.png`);
                }

                // Load hedle sprites
                for (let i = 1; i <= this.HEDLE_COUNT; i++) {
                    const num = i.toString().padStart(4, '0');
                    this.load.image(`body_${num}_ft`, BASE_URL + `assets/body_${num}_ft.png`);
                    this.load.image(`body_${num}_bk`, BASE_URL + `assets/body_${num}_bk.png`);
                    this.load.image(`body_${num}_L_sd`, BASE_URL + `assets/body_${num}_L_sd.png`);
                    this.load.image(`body_${num}_R_sd`, BASE_URL + `assets/body_${num}_R_sd.png`);
                }
            }

            create() {
                // EXACT same create() method as original...
                // Create golden dot texture for particles
                const graphics = this.make.graphics({ x: 0, y: 0, add: false });
                graphics.fillStyle(0xFFD700, 1);
                graphics.fillCircle(4, 4, 4);
                graphics.generateTexture('golden_dot', 8, 8);
                graphics.destroy();

                // Set background with tiled texture
                this.cameras.main.setBackgroundColor(0x2c3e50);

                // Tile the background texture
                const bgWidth = 900;
                const bgHeight = 1024;
                const tilesX = Math.ceil(this.gameWidth / bgWidth);
                const tilesY = Math.ceil(this.gameHeight / bgHeight);

                for (let x = 0; x < tilesX; x++) {
                    for (let y = 0; y < tilesY; y++) {
                        const bg = this.add.image(x * bgWidth, y * bgHeight, 'background');
                        bg.setOrigin(0, 0);
                        bg.setDepth(-10);
                    }
                }

                // Set world bounds for physics
                this.physics.world.setBounds(0, 0, this.gameWidth, this.gameHeight);
                this.physics.world.setBoundsCollision(true, true, true, true);

                // Create physics groups
                this.hedles = this.physics.add.group();
                this.heads = this.physics.add.group();
                this.eggs = [];

                // Create cannon
                this.cannon = this.add.image(this.gameWidth / 2, this.gameHeight - 100, 'cannon');
                this.cannon.setDisplaySize(this.CANNON_SIZE, this.CANNON_SIZE * 2);
                this.cannon.setOrigin(0.5, 0.5);
                this.cannon.setDepth(200);

                // Create horse - KEEP THE EXACT IMPLEMENTATION!
                this.createHorse();

                // Set up collision detection with condition check
                this.physics.add.overlap(this.heads, this.hedles, this.hitHedle, this.canHitHedle, this);
                this.physics.add.collider(this.heads, this.heads, this.headCollision, this.canHeadsCollide, this);

                // Create screen fade overlay for tension effect
                this.gameOverFadeOverlay = this.add.graphics();
                this.gameOverFadeOverlay.fillStyle(0x000000, 0);
                this.gameOverFadeOverlay.fillRect(0, 0, this.gameWidth, this.gameHeight);
                this.gameOverFadeOverlay.setDepth(50);

                // Input handling - KEEP EXACTLY AS IT WAS
                this.input.removeAllListeners();

                this.input.on('pointermove', (pointer) => {
                    this.lastPointerPosition = { x: pointer.x, y: pointer.y };
                    this.updateCannonAngle();
                });

                this.input.on('pointerdown', (pointer) => {
                    this.lastPointerPosition = { x: pointer.x, y: pointer.y };
                    this.updateCannonAngle();
                    if (!this.uiClickThisFrame) {
                        this.startFiring();
                    }
                });

                this.input.on('pointerup', () => {
                    this.stopFiring();
                });

                // Keyboard support
                this.spaceKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);
                this.spaceKey.on('down', () => {
                    this.startFiring();
                });
                this.spaceKey.on('up', () => {
                    this.stopFiring();
                });

                this.escapeKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.ESC);
                this.escapeKey.on('down', () => {
                    if (this.backgroundMusic && this.backgroundMusic.isPlaying) {
                        this.backgroundMusic.stop();
                    }
                    this.scene.start('StartScreen');
                });

                this.isFiring = false;

                // Initialize score display with 0
                this.updateScoreDisplay();

                // Create spell interface
                this.createSpellInterface();

                // Start spawning with first egg immediately - CRITICAL PART!
                this.triggerEggSpawn();
                this.scheduleNextEgg();

                // Schedule first bat
                this.scheduleBat();

                // Start background music
                if (this.cache.audio.exists('hedles_music')) {
                    this.backgroundMusic = this.sound.add('hedles_music', {
                        loop: true,
                        volume: 0.5
                    });
                    this.backgroundMusic.play();
                }

                // Hide loading message after a short delay to ensure everything is ready
                this.time.delayedCall(100, () => {
                    this.hideLoadingMessage();
                });
            }

            showLoadingMessage() {
                // Set black background immediately
                this.cameras.main.setBackgroundColor(0x000000);

                // Create loading text using system font initially
                this.loadingText = this.add.text(
                    this.gameWidth / 2,
                    this.gameHeight / 2,
                    'ENTERING THE TOWER...',
                    {
                        fontFamily: 'monospace',
                        fontSize: '32px',
                        fill: '#ffffff',
                        align: 'center'
                    }
                );
                this.loadingText.setOrigin(0.5);
                this.loadingText.setDepth(1000);
                this.loadingText.setAlpha(0);

                // Fade in and create pulsing animation
                this.tweens.add({
                    targets: this.loadingText,
                    alpha: 1,
                    duration: 500,
                    ease: 'Power2',
                    onComplete: () => {
                        this.loadingTween = this.tweens.add({
                            targets: this.loadingText,
                            alpha: 0.4,
                            duration: 1000,
                            yoyo: true,
                            repeat: -1,
                            ease: 'Sine.easeInOut'
                        });
                    }
                });

                // KEEP the sophisticated font upgrade system
                this.tryUpgradeLoadingFont();
            }

            tryUpgradeLoadingFont() {
                const fontLoaded = document.fonts.check('32px "Press Start 2P"');

                if (fontLoaded && this.loadingText && this.loadingText.active) {
                    this.loadingText.setFontFamily('"Press Start 2P", "Press Start 2P Local", monospace');
                    return;
                }

                const forceLoadFont = () => {
                    const testElement = document.createElement('div');
                    testElement.style.fontFamily = '"Press Start 2P", monospace';
                    testElement.style.fontSize = '32px';
                    testElement.style.position = 'absolute';
                    testElement.style.visibility = 'hidden';
                    testElement.style.left = '-9999px';
                    testElement.textContent = 'ENTERING THE TOWER...';
                    document.body.appendChild(testElement);

                    document.fonts.ready.then(() => {
                        setTimeout(() => {
                            const fontNowLoaded = document.fonts.check('32px "Press Start 2P"');

                            if (fontNowLoaded && this.loadingText && this.loadingText.active) {
                                this.loadingText.setFontFamily('"Press Start 2P", "Press Start 2P Local", monospace');
                            }

                            document.body.removeChild(testElement);
                        }, 50);
                    }).catch((error) => {
                        console.warn('Font loading failed for loading message:', error);
                        document.body.removeChild(testElement);
                    });
                };

                forceLoadFont();
            }

            hideLoadingMessage() {
                if (this.loadingText) {
                    if (this.loadingTween) {
                        this.loadingTween.destroy();
                    }

                    this.tweens.add({
                        targets: this.loadingText,
                        alpha: 0,
                        duration: 500,
                        ease: 'Power2',
                        onComplete: () => {
                            this.loadingText.destroy();
                            this.loadingText = null;
                        }
                    });
                }
            }

            // KEEP ALL HORSE METHODS EXACTLY AS THEY WERE!!!
            createHorse() {
                const spawnX = Phaser.Math.Between(150, this.gameWidth - 150);
                const spawnY = Phaser.Math.Between(50, 150);

                this.horse = this.add.sprite(spawnX, spawnY, 'horse_walk_1');
                this.horse.setDisplaySize(this.HORSE_SIZE, this.HORSE_SIZE);
                this.horse.setDepth(100);

                this.horseWalkFrame = 0;
                this.horseIsLaying = false;
                this.horseAngle = this.getRandomHorseDirection();
                this.horseVelocityX = Math.cos(this.horseAngle) * this.HORSE_SPEED;
                this.horseVelocityY = Math.sin(this.horseAngle) * this.HORSE_SPEED;

                this.startHorseWalking();
            }

            getRandomHorseDirection() {
                const goingLeft = Phaser.Math.Between(0, 1) === 0;

                if (goingLeft) {
                    return Phaser.Math.FloatBetween(157.5 * Math.PI / 180, 202.5 * Math.PI / 180);
                } else {
                    return Phaser.Math.FloatBetween(-22.5 * Math.PI / 180, 22.5 * Math.PI / 180);
                }
            }

            startHorseWalking() {
                this.horseWalkTimer = this.time.addEvent({
                    delay: this.HORSE_WALK_FRAME_DURATION,
                    callback: () => {
                        if (!this.horseIsLaying && this.horse && this.horse.active) {
                            this.horseWalkFrame = (this.horseWalkFrame % 8) + 1;
                            this.horse.setTexture(`horse_walk_${this.horseWalkFrame}`);
                        }
                    },
                    loop: true
                });
            }

            updateHorseMovement() {
                if (!this.horse || !this.horse.active || this.horseIsLaying) return;

                this.horse.x += this.horseVelocityX * (1 / 60);
                this.horse.y += this.horseVelocityY * (1 / 60);

                const margin = 60;
                let directionChanged = false;

                if (this.horse.x < margin) {
                    this.horse.x = margin;
                    this.horseVelocityX = Math.abs(this.horseVelocityX);
                    directionChanged = true;
                } else if (this.horse.x > this.gameWidth - margin) {
                    this.horse.x = this.gameWidth - margin;
                    this.horseVelocityX = -Math.abs(this.horseVelocityX);
                    directionChanged = true;
                }

                if (this.horse.y < 30) {
                    this.horse.y = 30;
                    this.horseVelocityY = Math.abs(this.horseVelocityY);
                    directionChanged = true;
                } else if (this.horse.y > 200) {
                    this.horse.y = 200;
                    this.horseVelocityY = -Math.abs(this.horseVelocityY);
                    directionChanged = true;
                }

                if (directionChanged) {
                    this.horseAngle = Math.atan2(this.horseVelocityY, this.horseVelocityX);
                }

                this.horse.setFlipX(this.horseVelocityX > 0);
            }

            triggerEggSpawn() {
                if (this.gameOver || !this.horse || !this.horse.active) return;
                this.pendingEggSpawn = true;
                this.startHorseLayingAnimation();
            }

            startHorseLayingAnimation() {
                if (this.horseIsLaying) return;

                this.horseIsLaying = true;

                if (this.horseWalkTimer) {
                    this.horseWalkTimer.paused = true;
                }

                let layFrame = 1;
                const layFrames = 3;

                const layAnimation = () => {
                    if (layFrame <= layFrames && this.horse && this.horse.active) {
                        this.horse.setTexture(`horse_egg_${layFrame}`);

                        if (layFrame === 2 && this.pendingEggSpawn) {
                            this.spawnEggAtHorse();
                            this.pendingEggSpawn = false;
                        }

                        layFrame++;

                        if (layFrame <= layFrames) {
                            this.time.delayedCall(this.HORSE_LAY_FRAME_DURATION, layAnimation);
                        } else {
                            this.endHorseLayingAnimation();
                        }
                    }
                };

                layAnimation();
            }

            endHorseLayingAnimation() {
                this.horseIsLaying = false;

                this.horseWalkFrame = 1;
                if (this.horse && this.horse.active) {
                    this.horse.setTexture(`horse_walk_${this.horseWalkFrame}`);
                }

                this.horseAngle = this.getRandomHorseDirection();
                this.horseVelocityX = Math.cos(this.horseAngle) * this.HORSE_SPEED;
                this.horseVelocityY = Math.sin(this.horseAngle) * this.HORSE_SPEED;

                if (this.horseWalkTimer) {
                    this.horseWalkTimer.paused = false;
                }
            }

            spawnEggAtHorse() {
                if (this.gameOver || !this.horse || !this.horse.active) return;

                const horseIsFlipped = this.horse.flipX;
                const rearOffsetDistance = 40;

                let spawnX, spawnY;

                if (horseIsFlipped) {
                    spawnX = this.horse.x - rearOffsetDistance;
                } else {
                    spawnX = this.horse.x + rearOffsetDistance;
                }

                spawnY = this.horse.y + 10;

                spawnX = Phaser.Math.Clamp(spawnX, 150, this.gameWidth - 150);
                spawnY = Phaser.Math.Clamp(spawnY, 50, 200);

                const egg = this.add.sprite(spawnX, spawnY, 'egg');
                egg.setDisplaySize(this.EGG_SIZE, this.EGG_SIZE);
                egg.hedleId = Phaser.Math.Between(1, this.HEDLE_COUNT).toString().padStart(4, '0');
                egg.growthTimer = 0;

                this.eggs.push(egg);

                const growthSteps = 4;
                for (let i = 1; i <= growthSteps; i++) {
                    const timer = this.time.delayedCall(i * 1000, () => {
                        if (egg && egg.active && !this.gameOver) {
                            const newSize = this.EGG_SIZE * (1 + i * 0.25);
                            egg.setDisplaySize(newSize, newSize);

                            this.tweens.add({
                                targets: egg,
                                scaleX: egg.scaleX * 1.1,
                                scaleY: egg.scaleY * 1.1,
                                duration: 200,
                                yoyo: true,
                                ease: 'Sine.easeInOut'
                            });
                        }
                    });
                    egg[`growthTimer${i}`] = timer;
                }

                egg.hatchTimer = this.time.delayedCall(this.EGG_GROWTH_TIME, () => {
                    if (egg && egg.active && !this.gameOver) {
                        this.hatchEgg(egg);
                    }
                });
            }

            scheduleNextEgg() {
                if (this.gameOver) return;

                this.eggSpawnTimer = this.time.delayedCall(this.currentSpawnDelay, () => {
                    this.triggerEggSpawn();
                    this.currentSpawnDelay *= this.spawnSpeedMultiplier;
                    this.currentSpawnDelay = Math.max(this.MINIMUM_SPAWN_DELAY, this.currentSpawnDelay);
                    this.scheduleNextEgg();
                });
            }

            hatchEgg(egg) {
                const hedleX = Phaser.Math.Clamp(egg.x, 80, this.gameWidth - 80);
                const hedleY = Phaser.Math.Clamp(egg.y, 80, this.gameHeight - 200);

                const hedle = this.physics.add.sprite(hedleX, hedleY, `body_${egg.hedleId}_ft`);

                hedle.setDisplaySize(this.HEDLE_SIZE, this.HEDLE_SIZE);
                hedle.body.setSize(24, 32);
                hedle.body.setOffset(12, 16);
                hedle.setCollideWorldBounds(true);
                hedle.body.setBounce(1, 1);
                hedle.body.setMaxVelocity(this.HEDLE_SPEED, this.HEDLE_SPEED);

                hedle.hedleId = egg.hedleId;
                hedle.currentSprite = 'ft';
                hedle.isDying = false;
                hedle.isMoving = false;
                hedle.walkSpriteIndex = 0;
                hedle.direction = Phaser.Math.FloatBetween(Math.PI * 0.25, Math.PI * 0.75);

                this.hedles.add(hedle);
                this.createBobAnimation(hedle);
                this.startMovementCycle(hedle);

                const index = this.eggs.indexOf(egg);
                if (index > -1) {
                    this.eggs.splice(index, 1);
                }

                egg.destroy();
            }

            // KEEP ALL OTHER METHODS EXACTLY AS THEY WERE...
            // [I'll include the key ones but for space I'm showing the pattern]

            createSpellInterface() {
                this.spellIcons = [];
                const slotY = this.gameHeight - 100;
                const leftSlotX = [this.gameWidth / 2 - 280, this.gameWidth / 2 - 160];
                const rightSlotX = [this.gameWidth / 2 + 160, this.gameWidth / 2 + 280];

                for (let i = 0; i < 4; i++) {
                    const x = i < 2 ? leftSlotX[i] : rightSlotX[i - 2];

                    const icon = this.add.image(x, slotY, 'icon_blank');
                    icon.setDisplaySize(this.SPELL_SLOT_SIZE, this.SPELL_SLOT_SIZE);
                    icon.setInteractive();
                    icon.slotIndex = i;
                    icon.setDepth(200);

                    const border = this.add.graphics();
                    border.lineStyle(4, 0xFFD800);
                    border.strokeRect(
                        x - this.SPELL_SLOT_SIZE / 2,
                        slotY - this.SPELL_SLOT_SIZE / 2,
                        this.SPELL_SLOT_SIZE,
                        this.SPELL_SLOT_SIZE
                    );
                    border.setVisible(false);
                    border.setDepth(200);
                    icon.border = border;

                    icon.on('pointerdown', () => {
                        if (!this.gameOver && !this.isMultiShotting) {
                            this.uiClickThisFrame = true;
                            this.time.delayedCall(10, () => {
                                this.uiClickThisFrame = false;
                            });
                            this.selectSpell(i);
                        }
                    });

                    this.spellIcons.push(icon);
                }
            }

            updateScoreDisplay() {
                this.scoreDigits.forEach(digit => digit.destroy());
                this.scoreDigits = [];

                const scoreStr = this.score.toString();
                const numDigits = scoreStr.length;
                const digitWidth = 64;
                const digitHeight = this.DIGIT_SIZE;
                const totalWidth = numDigits * digitWidth;
                const startX = (this.gameWidth / 2) - (totalWidth / 2) + (digitWidth / 2);

                for (let i = 0; i < numDigits; i++) {
                    const digitValue = scoreStr[i];
                    const digitX = startX + (i * digitWidth);

                    const digitSprite = this.add.image(digitX, 60, `digit_${digitValue}`);
                    digitSprite.setDisplaySize(digitWidth, digitHeight);
                    digitSprite.setDepth(200);

                    this.scoreDigits.push(digitSprite);
                }
            }

            animateScoreChange() {
                this.scoreDigits.forEach(digit => {
                    this.tweens.add({
                        targets: digit,
                        scaleX: 1.2,
                        scaleY: 1.2,
                        duration: 120,
                        yoyo: true,
                        ease: 'Back.easeOut'
                    });
                });
            }

            // ALL THE OTHER GAME METHODS STAY EXACTLY THE SAME...
            // startFiring, stopFiring, attemptToFire, startCannonCharge, fireCannon, etc.

            startFiring() {
                if (this.gameOver) return;
                this.isFiring = true;
                this.attemptToFire();
            }

            stopFiring() {
                this.isFiring = false;
            }

            attemptToFire() {
                if (!this.isFiring || this.gameOver || this.isMultiShotting) return;

                if (!this.cannonCharging && !this.cannonOnCooldown) {
                    this.startCannonCharge();
                } else {
                    this.shotQueued = true;
                }
            }

            startCannonCharge() {
                if (this.isMultiShotting) return;

                this.cannonCharging = true;
                this.cannonChargeStart = this.time.now;

                this.chargeTimer = this.time.delayedCall(this.CANNON_CHARGE_TIME, () => {
                    if (this.cannonCharging && !this.gameOver) {
                        this.fireCannon();
                    }
                });
            }

            fireCannon() {
                this.shotQueued = false;

                if (this.selectedSpell !== null && this.spellSlots[this.selectedSpell] === 'multi') {
                    const spell = this.consumeSelectedSpell();
                    if (spell) {
                        this.fireMultiShot();
                        return;
                    }
                }

                const activeSpell = this.selectedSpell !== null ? this.spellSlots[this.selectedSpell] : null;

                if (this.cache.audio.exists('cannon_shot')) {
                    this.sound.play('cannon_shot');
                }

                this.cannonCharging = false;
                this.cannon.setTint(0xffffff);
                this.cannonOnCooldown = true;
                this.cannonCooldownStart = this.time.now;

                const cannonLength = this.CANNON_SIZE;
                const spawnOffsetX = Math.cos(this.cannonAngle) * (cannonLength * 0.8);
                const spawnOffsetY = Math.sin(this.cannonAngle) * (cannonLength * 0.8);

                const headNum = Phaser.Math.Between(1, this.HEAD_COUNT);
                const headId = headNum.toString().padStart(4, '0');

                const head = this.physics.add.sprite(
                    this.cannon.x + spawnOffsetX,
                    this.cannon.y + spawnOffsetY,
                    `head_${headId}`
                );

                this.heads.add(head);

                head.setDisplaySize(this.HEAD_SIZE, this.HEAD_SIZE);
                head.setOrigin(0.5, 0.25);
                head.body.setSize(18, 18);
                head.body.setOffset(16, 4);

                if (activeSpell) {
                    head.spellType = activeSpell;
                    head.hasHitHedle = false;
                    this.consumeSelectedSpell();

                    if (activeSpell === 'storm') {
                        head.isPiercing = true;
                        this.addStormTrail(head);
                    } else {
                        head.body.setBounce(1, 1);
                    }

                    if (activeSpell !== 'storm') {
                        const spellVisual = this.add.image(head.x, head.y, `spell_${activeSpell}`);
                        spellVisual.setDisplaySize(80, 80);
                        head.spellVisual = spellVisual;
                    }
                } else {
                    head.body.setBounce(1, 1);
                }

                head.body.setDrag(0);

                const velocityX = Math.cos(this.cannonAngle) * this.HEAD_SPEED;
                const velocityY = Math.sin(this.cannonAngle) * this.HEAD_SPEED;

                head.body.velocity.set(velocityX, velocityY);
            }

            selectSpell(index) {
                if (!this.spellSlots[index]) return;
                this.stopFiring();
                this.spellIcons.forEach(icon => {
                    icon.border.setVisible(false);
                });

                if (this.selectedSpell === index) {
                    this.selectedSpell = null;
                } else {
                    this.selectedSpell = index;
                    this.spellIcons[index].border.setVisible(true);
                }
            }

            consumeSelectedSpell() {
                if (this.selectedSpell === null) return null;

                const spell = this.spellSlots[this.selectedSpell];
                if (!spell) return null;

                this.spellSlots[this.selectedSpell] = null;
                this.spellIcons[this.selectedSpell].setTexture('icon_blank');
                this.spellIcons[this.selectedSpell].border.setVisible(false);

                const consumedSpell = spell;
                this.selectedSpell = null;

                return consumedSpell;
            }

            updateCannonAngle() {
                const cannonX = this.cannon.x;
                const cannonY = this.cannon.y;

                this.cannonAngle = Phaser.Math.Angle.Between(
                    cannonX, cannonY,
                    this.lastPointerPosition.x, this.lastPointerPosition.y
                );

                if (this.cannonAngle > 0) {
                    this.cannonAngle = 0;
                } else if (this.cannonAngle < -Math.PI) {
                    this.cannonAngle = -Math.PI;
                }

                this.cannon.setRotation(this.cannonAngle + Math.PI / 2);
            }

            createBobAnimation(hedle) {
                const currentScaleX = hedle.scaleX;
                const currentScaleY = hedle.scaleY;

                hedle.bobTween = this.tweens.add({
                    targets: hedle,
                    scaleY: currentScaleY * 1.02,
                    scaleX: currentScaleX * 0.98,
                    duration: 500,
                    yoyo: true,
                    repeat: -1,
                    ease: 'Sine.easeInOut'
                });
            }

            startMovementCycle(hedle) {
                if (hedle.isDying || !hedle.active) return;

                hedle.isMoving = true;
                hedle.walkSpriteIndex = 0;
                hedle.direction = Phaser.Math.FloatBetween(Math.PI * 0.25, Math.PI * 0.75);

                const velX = Math.cos(hedle.direction) * this.HEDLE_SPEED;
                const velY = Math.sin(hedle.direction) * this.HEDLE_SPEED;
                hedle.body.setVelocity(velX, velY);

                hedle.walkTimer = this.time.addEvent({
                    delay: this.HEDLE_WALK_SPRITE_INTERVAL,
                    callback: () => {
                        if (!hedle.isDying && hedle.active && hedle.isMoving) {
                            hedle.walkSpriteIndex = (hedle.walkSpriteIndex + 1) % 2;
                            const side = hedle.walkSpriteIndex === 0 ? 'L_sd' : 'R_sd';
                            hedle.setTexture(`body_${hedle.hedleId}_${side}`);
                        }
                    },
                    loop: true
                });

                hedle.moveCycleTimer = this.time.delayedCall(this.HEDLE_MOVE_TIME, () => {
                    if (hedle.isDying || !hedle.active) return;

                    hedle.isMoving = false;
                    hedle.body.setVelocity(0, 0);

                    if (hedle.walkTimer) hedle.walkTimer.destroy();
                    hedle.setTexture(`body_${hedle.hedleId}_ft`);

                    hedle.waitCycleTimer = this.time.delayedCall(this.HEDLE_WAIT_TIME, () => {
                        this.startMovementCycle(hedle);
                    });
                });
            }

            canHitHedle(head, hedle) {
                const speed = Math.sqrt(head.body.velocity.x ** 2 + head.body.velocity.y ** 2);
                return speed >= this.MIN_HEAD_DAMAGE_SPEED && !hedle.isDying;
            }

            hitHedle(head, hedle) {
                if (hedle.isDying) return;

                if (head.spellType || head.multiVisual) {
                    head.hasHitHedle = true;
                }

                // Check for spell effects
                if (head.spellType) {
                    if (head.spellType === 'fire') {
                        this.executeFireSpell(head.x, head.y);
                        if (head.spellVisual && head.spellVisual.active) {
                            head.spellVisual.destroy();
                        }
                    } else if (head.spellType === 'water') {
                        this.executeWaterSpell(head.x, head.y);
                        if (head.spellVisual && head.spellVisual.active) {
                            head.spellVisual.destroy();
                        }
                    }

                    if (head.spellType !== 'storm') {
                        head.spellType = null;
                    }
                }

                hedle.isDying = true;

                const owwSounds = ['oww_1', 'oww_2', 'oww_3', 'oww_4'];
                const randomOww = Phaser.Utils.Array.GetRandom(owwSounds);
                if (this.cache.audio.exists(randomOww)) {
                    this.sound.play(randomOww);
                }

                if (hedle.walkTimer) hedle.walkTimer.destroy();
                if (hedle.bobTween) hedle.bobTween.destroy();
                if (hedle.moveCycleTimer) hedle.moveCycleTimer.destroy();
                if (hedle.waitCycleTimer) hedle.waitCycleTimer.destroy();

                hedle.body.setVelocity(0, 0);
                hedle.body.enable = false;

                const currentY = hedle.y;
                hedle.setOrigin(0.5, 1);
                hedle.y = currentY + (hedle.displayHeight / 2);

                const fallDirection = Phaser.Math.Between(0, 1) === 0 ? -1 : 1;

                this.tweens.add({
                    targets: hedle,
                    rotation: (Math.PI / 2) * fallDirection,
                    alpha: 0,
                    duration: 1000,
                    onComplete: () => hedle.destroy()
                });

                this.score++;
                this.updateScoreDisplay();
                this.animateScoreChange();

                if (!head.isPiercing) {
                    const currentSpeed = Math.sqrt(head.body.velocity.x ** 2 + head.body.velocity.y ** 2);
                    const newSpeed = currentSpeed * 0.5;
                    const bounceAngle = Phaser.Math.FloatBetween(0, Math.PI * 2);
                    const newVelX = Math.cos(bounceAngle) * newSpeed;
                    const newVelY = Math.sin(bounceAngle) * newSpeed;
                    head.body.setVelocity(newVelX, newVelY);
                }
            }

            headCollision(head1, head2) {
                if (this.cache.audio.exists('ball_bounce')) {
                    this.sound.play('ball_bounce');
                }
            }

            canHeadsCollide(head1, head2) {
                const head1IsSpecial = head1.spellType || head1.multiVisual;
                const head2IsSpecial = head2.spellType || head2.multiVisual;

                if (!head1IsSpecial && !head2IsSpecial) {
                    return true;
                }

                if ((head1IsSpecial && head1.spellType === 'storm') ||
                    (head2IsSpecial && head2.spellType === 'storm')) {
                    return false;
                }

                if (head1IsSpecial && head1.hasHitHedle === false) {
                    return false;
                }
                if (head2IsSpecial && head2.hasHitHedle === false) {
                    return false;
                }

                return true;
            }

            checkGameOver() {
                this.hedles.children.entries.forEach(hedle => {
                    if (!hedle.isDying && hedle.y > this.gameHeight - 160) {
                        this.endGame();
                    }
                });
            }

            // Use shared text wrapping in game over but keep all the original game over logic
            createGameOverTypewriter(x, y, callback) {
                const message = Phaser.Utils.Array.GetRandom(this.gameOverMessages);

                const fontFamily = '"Press Start 2P", "Press Start 2P Local", monospace';
                const fontSize = this.fontLoaded ? '32px' : '36px';

                const wrapWidth = this.gameWidth * 0.96;

                // Use shared text wrapping utility
                const wrappedMessage = SharedUtils.wrapText(message, fontFamily, fontSize, wrapWidth, this);

                this.gameOverMessage = this.add.text(x, y, '', {
                    fontFamily: fontFamily,
                    fontSize: fontSize,
                    fill: '#ff0000',
                    align: 'center'
                });
                this.gameOverMessage.setOrigin(0.5);
                this.gameOverMessage.setDepth(200);

                this.gameOverTyping = true;
                this.gameOverCanAdvance = false;
                this.gameOverWrappedText = wrappedMessage;

                let currentText = '';
                let charIndex = 0;
                const typewriterSpeed = 80;

                const typeNextChar = () => {
                    if (charIndex < wrappedMessage.length && this.gameOverTyping) {
                        currentText += wrappedMessage[charIndex];
                        this.gameOverMessage.setText(currentText);

                        if (wrappedMessage[charIndex] !== ' ' && wrappedMessage[charIndex] !== '\n' && this.typewriterSounds.length > 0) {
                            const randomSound = Phaser.Utils.Array.GetRandom(this.typewriterSounds);
                            this.sound.play(randomSound, { volume: 0.3 });
                        }

                        charIndex++;
                        this.typewriterTimer = this.time.delayedCall(typewriterSpeed, typeNextChar);
                    } else {
                        this.completeGameOverTypewriter(callback);
                    }
                };

                const gameOverAdvanceHandler = () => {
                    if (this.gameOverTyping) {
                        this.completeGameOverTypewriter(callback, true);
                    } else if (this.gameOverCanAdvance) {
                        this.handleGameOverComplete(callback);
                    }
                };

                this.input.off('pointerdown', this.gameOverPointerHandler);
                this.gameOverPointerHandler = gameOverAdvanceHandler;
                this.input.on('pointerdown', this.gameOverPointerHandler);

                if (this.gameOverSpaceKey) {
                    this.gameOverSpaceKey.off('down');
                }
                this.gameOverSpaceKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);
                this.gameOverSpaceKey.on('down', gameOverAdvanceHandler);

                typeNextChar();
            }

            completeGameOverTypewriter(callback, wasSkipped = false) {
                this.gameOverTyping = false;
                this.gameOverCanAdvance = true;

                if (this.typewriterTimer) {
                    this.typewriterTimer.destroy();
                }

                this.gameOverMessage.setText(this.gameOverWrappedText);

                if (wasSkipped) {
                    this.time.delayedCall(500, () => {
                        this.handleGameOverComplete(callback);
                    });
                } else {
                    this.time.delayedCall(1500, () => {
                        this.handleGameOverComplete(callback);
                    });
                }
            }

            handleGameOverComplete(callback) {
                this.input.off('pointerdown', this.gameOverPointerHandler);
                if (this.gameOverSpaceKey) {
                    this.gameOverSpaceKey.off('down');
                }

                this.time.delayedCall(2000, () => {
                    if (callback) callback();
                });
            }

            createGameOverPlayButton(x, y) {
                this.gameOverPlayButton = this.add.image(x, y, 'click_play');
                this.gameOverPlayButton.setDisplaySize(384, 192);
                this.gameOverPlayButton.setInteractive();
                this.gameOverPlayButton.setDepth(200);

                this.gameOverPlayButton.on('pointerover', () => {
                    this.gameOverPlayButton.setTint(0xcccccc);
                });
                this.gameOverPlayButton.on('pointerout', () => {
                    this.gameOverPlayButton.setTint(0xffffff);
                });
                this.gameOverPlayButton.on('pointerdown', () => {
                    SharedUtils.buttonPress(this, this.gameOverPlayButton, 'click_play2', () => {
                        this.scene.restart();
                    });
                });
            }

            scheduleBat() {
                if (this.gameOver) return;

                this.batTimer = this.time.delayedCall(this.currentBatDelay, () => {
                    this.spawnBat();
                    this.currentBatDelay += this.batDelayIncrement;
                    this.scheduleBat();
                });
            }

            spawnBat() {
                if (this.gameOver) return;

                const minY = this.gameHeight * 0.2;
                const maxY = this.gameHeight * 0.8;
                const batY = Phaser.Math.Between(minY, maxY);

                const goingRight = Phaser.Math.Between(0, 1) === 1;
                const startX = goingRight ? -150 : this.gameWidth + 150;
                const endX = goingRight ? this.gameWidth + 150 : -150;

                const bat = this.add.sprite(startX, batY, 'bat_1');
                bat.setDisplaySize(180, 180);
                bat.setDepth(300);

                if (!goingRight) {
                    bat.setFlipX(true);
                }

                const batParticles = this.add.particles(startX, batY, 'golden_dot', {
                    scale: { start: 0.6, end: 0.2 },
                    alpha: { start: 1.0, end: 0.2 },
                    speed: { min: 40, max: 80 },
                    lifespan: 2000,
                    frequency: 100,
                    quantity: 2,
                    emitZone: {
                        type: 'random',
                        source: new Phaser.Geom.Circle(0, 0, 64),
                        quantity: 2
                    }
                });
                batParticles.setDepth(300);

                let batFrame = 0;
                const batFrames = ['bat_1', 'bat_2', 'bat_3', 'bat_4'];
                bat.animTimer = this.time.addEvent({
                    delay: 100,
                    callback: () => {
                        batFrame = (batFrame + 1) % 4;
                        bat.setTexture(batFrames[batFrame]);
                    },
                    loop: true
                });

                const bookTypes = ['fire', 'water', 'storm', 'multi'];
                const bookType = Phaser.Utils.Array.GetRandom(bookTypes);
                const book = this.add.image(startX, batY + 60, `tome_${bookType}`);
                book.setDisplaySize(90, 90);
                book.setInteractive();
                book.bookType = bookType;
                book.setDepth(300);

                book.on('pointerdown', () => {
                    this.uiClickThisFrame = true;
                    this.time.delayedCall(10, () => {
                        this.uiClickThisFrame = false;
                    });

                    if (this.addSpellToSlot(bookType)) {
                        if (this.cache.audio.exists('pickup_spell')) {
                            this.sound.play('pickup_spell');
                        }

                        book.destroy();
                        const collected = this.add.text(book.x, book.y, `+${bookType.toUpperCase()}`, {
                            fontSize: '32px',
                            fill: '#FFD800'
                        }).setOrigin(0.5);

                        this.tweens.add({
                            targets: collected,
                            y: collected.y - 50,
                            alpha: 0,
                            duration: 1000,
                            onComplete: () => collected.destroy()
                        });
                    }
                });

                this.tweens.add({
                    targets: [bat, book, batParticles],
                    x: endX,
                    duration: this.gameWidth / this.BAT_SPEED * 1000,
                    onComplete: () => {
                        if (bat.animTimer) bat.animTimer.destroy();
                        bat.destroy();
                        if (book.active) book.destroy();
                        batParticles.destroy();
                    }
                });
            }

            addSpellToSlot(spellType) {
                const emptyIndex = this.spellSlots.indexOf(null);
                if (emptyIndex === -1) return false;

                this.spellSlots[emptyIndex] = spellType;
                this.spellIcons[emptyIndex].setTexture(`icon_${spellType}`);

                return true;
            }

            // [Continue with ALL other methods exactly as they were...]
            // executeFireSpell, executeWaterSpell, addStormTrail, fireMultiShot, etc.

            update(time, delta) {
                if (this.gameOver) return;

                // CRITICAL: Keep the horse movement update!
                this.updateHorseMovement();

                // [All the rest of the update method exactly as original...]
                if (this.cannonOnCooldown) {
                    const elapsed = this.time.now - this.cannonCooldownStart;
                    if (elapsed >= this.CANNON_COOLDOWN_TIME) {
                        this.cannonOnCooldown = false;
                        if (this.shotQueued && !this.isMultiShotting) {
                            this.shotQueued = false;
                            this.startCannonCharge();
                        } else if (this.isFiring && !this.isMultiShotting) {
                            this.attemptToFire();
                        }
                    }
                }

                if (this.cannonCharging) {
                    const chargeProgress = (this.time.now - this.cannonChargeStart) / this.CANNON_CHARGE_TIME;
                    const shakeIntensity = Math.min(chargeProgress * 10, 10);

                    this.cannon.x = this.gameWidth / 2 + (Math.random() - 0.5) * shakeIntensity;
                    this.cannon.y = this.gameHeight - 100 + (Math.random() - 0.5) * shakeIntensity;
                    this.cannon.setTint(0xff4444);
                } else {
                    this.cannon.x = this.gameWidth / 2;
                    this.cannon.y = this.gameHeight - 100;

                    if (this.selectedSpell !== null && this.spellSlots[this.selectedSpell]) {
                        const spellType = this.spellSlots[this.selectedSpell];
                        if (spellType === 'fire') {
                            this.cannon.setTint(0xff6600);
                        } else if (spellType === 'water') {
                            this.cannon.setTint(0x0099ff);
                        } else if (spellType === 'storm') {
                            this.cannon.setTint(0x9900ff);
                        } else if (spellType === 'multi') {
                            this.cannon.setTint(0x00ff00);
                        }
                    } else {
                        this.cannon.setTint(0xffffff);
                    }
                }

                this.heads.children.entries.forEach(head => {
                    if (head.spellVisual && head.spellVisual.active) {
                        head.spellVisual.x = head.x;
                        head.spellVisual.y = head.y;
                    }
                    if (head.multiVisual && head.multiVisual.active) {
                        head.multiVisual.x = head.x;
                        head.multiVisual.y = head.y;
                    }

                    if (head.body) {
                        const speed = Math.sqrt(head.body.velocity.x ** 2 + head.body.velocity.y ** 2);
                        const rotationSpeed = speed * 0.008;
                        head.rotation += rotationSpeed * delta * 0.001;
                    }
                });

                this.updateScreenFade(delta);

                this.hedles.children.entries.forEach(hedle => {
                    if (!hedle.isDying && hedle.isMoving) {
                        if (hedle.x < 40) {
                            hedle.x = 40;
                            hedle.body.setVelocityX(Math.abs(hedle.body.velocity.x));
                        } else if (hedle.x > this.gameWidth - 40) {
                            hedle.x = this.gameWidth - 40;
                            hedle.body.setVelocityX(-Math.abs(hedle.body.velocity.x));
                        }

                        if (hedle.y < 40) {
                            hedle.y = 40;
                            hedle.body.setVelocityY(Math.abs(hedle.body.velocity.y));
                        }
                    }
                });

                this.heads.children.entries.forEach(head => {
                    if (head.x < -200 || head.x > this.gameWidth + 200 ||
                        head.y < -200 || head.y > this.gameHeight + 200) {
                        this.cleanupHead(head);
                    }
                });

                this.checkGameOver();
            }

            updateScreenFade(delta) {
                if (!this.gameOverFadeOverlay) return;

                this.fadeUpdateCounter++;
                if (this.fadeUpdateCounter < 4) return;
                this.fadeUpdateCounter = 0;

                let maxThreatLevel = 0;

                this.hedles.children.entries.forEach(hedle => {
                    if (!hedle.isDying) {
                        const threatZoneStart = this.gameHeight * 0.2;
                        const gameOverZone = this.gameHeight - 160;

                        if (hedle.y > threatZoneStart) {
                            const threatLevel = Math.min((hedle.y - threatZoneStart) / (gameOverZone - threatZoneStart), 1);
                            maxThreatLevel = Math.max(maxThreatLevel, threatLevel);
                        }
                    }
                });

                const newTargetOpacity = maxThreatLevel * 0.8;

                if (newTargetOpacity !== this.targetFadeOpacity ||
                    Math.abs(this.currentFadeOpacity - this.targetFadeOpacity) > 0.01) {

                    this.targetFadeOpacity = newTargetOpacity;

                    const deltaSeconds = (delta * 4) * 0.001;
                    const transitionAmount = this.fadeTransitionSpeed * deltaSeconds;

                    if (this.currentFadeOpacity < this.targetFadeOpacity) {
                        this.currentFadeOpacity = Math.min(
                            this.currentFadeOpacity + transitionAmount * 1.2,
                            this.targetFadeOpacity
                        );
                    } else if (this.currentFadeOpacity > this.targetFadeOpacity) {
                        this.currentFadeOpacity = Math.max(
                            this.currentFadeOpacity - transitionAmount * 0.8,
                            this.targetFadeOpacity
                        );
                    }

                    this.gameOverFadeOverlay.clear();
                    if (this.currentFadeOpacity > 0) {
                        this.gameOverFadeOverlay.fillStyle(0x000000, this.currentFadeOpacity);
                        this.gameOverFadeOverlay.fillRect(0, 0, this.gameWidth, this.gameHeight);
                    }
                }
            }

            endGame() {
                if (this.gameOver) return;

                this.gameOver = true;
                this.stopFiring();

                if (this.backgroundMusic && this.backgroundMusic.isPlaying) {
                    this.backgroundMusic.stop();
                }

                if (this.eggSpawnTimer) this.eggSpawnTimer.destroy();
                if (this.chargeTimer) this.chargeTimer.destroy();
                if (this.batTimer) this.batTimer.destroy();
                if (this.horseWalkTimer) this.horseWalkTimer.destroy();

                if (this.horse && this.horse.active) {
                    this.horseVelocityX = 0;
                    this.horseVelocityY = 0;
                    this.horseIsLaying = false;
                }

                this.hedles.children.entries.forEach(hedle => {
                    if (hedle.body) hedle.body.setVelocity(0, 0);
                    if (hedle.walkTimer) hedle.walkTimer.destroy();
                    if (hedle.bobTween) hedle.bobTween.destroy();
                    if (hedle.moveCycleTimer) hedle.moveCycleTimer.destroy();
                    if (hedle.waitCycleTimer) hedle.waitCycleTimer.destroy();
                });

                this.eggs.forEach(egg => {
                    for (let i = 1; i <= 4; i++) {
                        if (egg[`growthTimer${i}`]) egg[`growthTimer${i}`].destroy();
                    }
                    if (egg.hatchTimer) egg.hatchTimer.destroy();
                    egg.destroy();
                });
                this.eggs = [];

                this.heads.children.entries.forEach(head => {
                    this.cleanupHead(head);
                });

                if (this.spellIcons) {
                    this.spellIcons.forEach(icon => {
                        icon.setVisible(false);
                        if (icon.border) icon.border.setVisible(false);
                    });
                }

                this.scoreDigits.forEach(digit => {
                    this.tweens.add({
                        targets: digit,
                        scaleX: 1.1,
                        scaleY: 1.1,
                        duration: 1000,
                        yoyo: true,
                        repeat: -1,
                        ease: 'Sine.easeInOut'
                    });
                });

                this.createGameOverTypewriter(
                    this.gameWidth / 2,
                    this.gameHeight / 2,
                    () => {
                        this.createGameOverPlayButton(
                            this.gameWidth / 2,
                            this.gameHeight / 2 + 200
                        );
                    }
                );
            }

            cleanupHead(head) {
                if (head.trailTimer) head.trailTimer.destroy();
                if (head.spellVisual && head.spellVisual.active) head.spellVisual.destroy();
                if (head.multiVisual && head.multiVisual.active) head.multiVisual.destroy();
                head.destroy();
            }

            // KEEP ALL REMAINING METHODS EXACTLY AS THEY WERE...
            // Adding the essential ones that are called but not yet defined

            executeFireSpell(x, y) {
                const numExplosions = 16;
                for (let i = 0; i < numExplosions; i++) {
                    const angle = (i / numExplosions) * Math.PI * 2;
                    const explosionX = x + Math.cos(angle) * this.FIRE_EXPLOSION_RADIUS;
                    const explosionY = y + Math.sin(angle) * this.FIRE_EXPLOSION_RADIUS;

                    const explosion = this.add.image(explosionX, explosionY, 'spell_fire');
                    explosion.setDisplaySize(80, 80);

                    this.tweens.add({
                        targets: explosion,
                        alpha: 0,
                        scaleX: 1.5,
                        scaleY: 1.5,
                        duration: 1000,
                        onComplete: () => explosion.destroy()
                    });
                }

                this.hedles.children.entries.forEach(hedle => {
                    if (!hedle.isDying) {
                        const distance = Phaser.Math.Distance.Between(x, y, hedle.x, hedle.y);
                        if (distance <= this.FIRE_EXPLOSION_RADIUS) {
                            this.killHedleBySpell(hedle);
                        }
                    }
                });
            }

            executeWaterSpell(x, y) {
                const angle = Phaser.Math.FloatBetween(0, Math.PI * 2);
                const numSegments = 40;
                const waveLength = 400;

                for (let i = 0; i < numSegments; i++) {
                    const segmentDist = (i / numSegments) * this.WATER_LINE_LENGTH - this.WATER_LINE_LENGTH / 2;
                    const waterX = x + Math.cos(angle) * segmentDist;
                    const waterY = y + Math.sin(angle) * segmentDist;

                    const water = this.add.image(waterX, waterY, 'spell_water');
                    water.setDisplaySize(60, 60);
                    water.setRotation(angle);

                    const wavePhase = (Math.abs(segmentDist) % waveLength) / waveLength * Math.PI * 2;
                    const waveAmplitude = 25;
                    const waveFrequency = 800;

                    const perpAngle = angle + Math.PI / 2;
                    const startX = water.x;
                    const startY = water.y;

                    this.tweens.add({
                        targets: water,
                        x: startX + Math.cos(perpAngle) * waveAmplitude,
                        y: startY + Math.sin(perpAngle) * waveAmplitude,
                        duration: waveFrequency / 2,
                        delay: wavePhase * 100,
                        yoyo: true,
                        repeat: 3,
                        ease: 'Sine.easeInOut'
                    });

                    this.tweens.add({
                        targets: water,
                        alpha: 0,
                        duration: 2000,
                        onComplete: () => water.destroy()
                    });
                }

                this.hedles.children.entries.forEach(hedle => {
                    if (!hedle.isDying) {
                        const lineStart = {
                            x: x - Math.cos(angle) * this.WATER_LINE_LENGTH / 2,
                            y: y - Math.sin(angle) * this.WATER_LINE_LENGTH / 2
                        };
                        const lineEnd = {
                            x: x + Math.cos(angle) * this.WATER_LINE_LENGTH / 2,
                            y: y + Math.sin(angle) * this.WATER_LINE_LENGTH / 2
                        };

                        const distToLine = this.distanceToLine(hedle, lineStart, lineEnd);
                        if (distToLine <= 40) {
                            this.killHedleBySpell(hedle);
                        }
                    }
                });
            }

            distanceToLine(point, lineStart, lineEnd) {
                const A = point.x - lineStart.x;
                const B = point.y - lineStart.y;
                const C = lineEnd.x - lineStart.x;
                const D = lineEnd.y - lineStart.y;

                const dot = A * C + B * D;
                const lenSq = C * C + D * D;
                let param = -1;

                if (lenSq !== 0) param = dot / lenSq;

                let xx, yy;

                if (param < 0) {
                    xx = lineStart.x;
                    yy = lineStart.y;
                } else if (param > 1) {
                    xx = lineEnd.x;
                    yy = lineEnd.y;
                } else {
                    xx = lineStart.x + param * C;
                    yy = lineStart.y + param * D;
                }

                const dx = point.x - xx;
                const dy = point.y - yy;

                return Math.sqrt(dx * dx + dy * dy);
            }

            killHedleBySpell(hedle) {
                if (hedle.isDying) return;

                hedle.isDying = true;

                const owwSounds = ['oww_1', 'oww_2', 'oww_3', 'oww_4'];
                const randomOww = Phaser.Utils.Array.GetRandom(owwSounds);
                if (this.cache.audio.exists(randomOww)) {
                    this.sound.play(randomOww);
                }

                if (hedle.walkTimer) hedle.walkTimer.destroy();
                if (hedle.bobTween) hedle.bobTween.destroy();
                if (hedle.moveCycleTimer) hedle.moveCycleTimer.destroy();
                if (hedle.waitCycleTimer) hedle.waitCycleTimer.destroy();

                hedle.body.setVelocity(0, 0);
                hedle.body.enable = false;

                this.tweens.add({
                    targets: hedle,
                    alpha: 0,
                    scaleX: 0,
                    scaleY: 0,
                    duration: 500,
                    onComplete: () => hedle.destroy()
                });

                this.score++;
                this.updateScoreDisplay();
                this.animateScoreChange();
            }

            addStormTrail(head) {
                head.trailTimer = this.time.addEvent({
                    delay: 50,
                    callback: () => {
                        if (!head.active) {
                            head.trailTimer.destroy();
                            return;
                        }

                        const trail = this.add.image(head.x, head.y, 'spell_storm');
                        trail.setDisplaySize(60, 60);
                        trail.setAlpha(0.8);

                        this.tweens.add({
                            targets: trail,
                            alpha: 0,
                            duration: 500,
                            onComplete: () => trail.destroy()
                        });
                    },
                    loop: true
                });
            }

            fireMultiShot() {
                this.isMultiShotting = true;
                this.shotQueued = false;
                let shotCount = 0;

                const shootNext = () => {
                    if (shotCount >= this.MULTI_SHOT_COUNT || this.gameOver) {
                        this.isMultiShotting = false;
                        return;
                    }

                    if (this.cache.audio.exists('cannon_shot')) {
                        this.sound.play('cannon_shot');
                    }

                    const cannonLength = this.CANNON_SIZE;
                    const spawnOffsetX = Math.cos(this.cannonAngle) * (cannonLength * 0.8);
                    const spawnOffsetY = Math.sin(this.cannonAngle) * (cannonLength * 0.8);

                    const headNum = Phaser.Math.Between(1, this.HEAD_COUNT);
                    const headId = headNum.toString().padStart(4, '0');

                    const head = this.physics.add.sprite(
                        this.cannon.x + spawnOffsetX,
                        this.cannon.y + spawnOffsetY,
                        `head_${headId}`
                    );

                    this.heads.add(head);
                    head.setDisplaySize(this.HEAD_SIZE, this.HEAD_SIZE);
                    head.setOrigin(0.5, 0.25);
                    head.body.setSize(18, 18);
                    head.body.setOffset(16, 4);
                    head.body.setBounce(1, 1);
                    head.body.setDrag(0);

                    head.hasHitHedle = false;

                    const spellVisual = this.add.image(head.x, head.y, 'spell_multi');
                    spellVisual.setDisplaySize(60, 60);
                    head.multiVisual = spellVisual;

                    this.tweens.add({
                        targets: spellVisual,
                        alpha: 0,
                        duration: 1000,
                        onComplete: () => spellVisual.destroy()
                    });

                    const velocityX = Math.cos(this.cannonAngle) * this.HEAD_SPEED;
                    const velocityY = Math.sin(this.cannonAngle) * this.HEAD_SPEED;
                    head.body.velocity.set(velocityX, velocityY);

                    shotCount++;

                    this.time.delayedCall(this.MULTI_SHOT_DELAY, shootNext);
                };

                this.cannonCharging = false;
                this.cannon.setTint(0xffffff);

                shootNext();
            }
        }

        // Game configuration
        const config = {
            type: Phaser.AUTO,
            width: 900,
            height: 1600,
            parent: 'game-container',
            physics: {
                default: 'arcade',
                arcade: {
                    gravity: { y: 0 },
                    debug: false
                }
            },
            scene: [StartScreen, StoryScreen, GameScreen],
            scale: {
                mode: Phaser.Scale.FIT,
                autoCenter: Phaser.Scale.CENTER_BOTH
            }
        };

        const game = new Phaser.Game(config);
    </script>
</body>

</html>