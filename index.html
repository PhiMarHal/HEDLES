<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>HEDLES</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/phaser/3.70.0/phaser.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100vh;
            background: #000000;
            font-family: monospace;
            touch-action: none;
            overflow: hidden;
            position: fixed;
            top: 0;
            left: 0;
        }

        html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
        }
    </style>
</head>

<body>
    <div id="game-container"></div>

    <script>
        // Start Screen Scene
        class StartScreen extends Phaser.Scene {
            constructor() {
                super({ key: 'StartScreen' });
                this.gameWidth = 900;
                this.gameHeight = 1600;
            }

            preload() {
                // Load start screen assets
                this.load.image('cover_hedles', 'assets/cover_hedles.jpg');
                this.load.image('click_story', 'assets/click_story.png');
                this.load.image('click_story2', 'assets/click_story2.png');
                this.load.image('click_play', 'assets/click_play.png');
                this.load.image('click_play2', 'assets/click_play2.png');
                this.load.audio('tap_button', 'assets/tap_button.mp3');

                // Error handlers for missing assets
                this.load.on('loaderror', (file) => {
                    console.warn('Missing start screen asset:', file.key);
                    const graphics = this.make.graphics({ x: 0, y: 0, add: false });

                    if (file.key === 'cover_hedles') {
                        graphics.fillStyle(0x2c3e50, 1);
                        graphics.fillRect(0, 0, 1024, 1220);
                        graphics.fillStyle(0xffffff, 1);
                        graphics.fillRect(412, 610, 200, 50);
                        graphics.generateTexture('cover_hedles', 1024, 1220);
                    } else if (file.key.startsWith('click_story') || file.key.startsWith('click_play')) {
                        const isGolden = file.key.includes('2');
                        graphics.fillStyle(0x444444, 1);
                        graphics.fillRect(0, 0, 512, 256);
                        graphics.fillStyle(isGolden ? 0xFFD700 : 0xffffff, 1);
                        graphics.fillRect(20, 50, 472, 156);
                        graphics.generateTexture(file.key, 512, 256);
                    }

                    graphics.destroy();
                });
            }

            create() {
                // Black background
                this.cameras.main.setBackgroundColor(0x000000);

                // Layout calculations for 900x1600 canvas with 1024x1220 book:
                // Scale book to fit width: 900/1024 = 0.878
                // Scaled book: 900 x 1071px 
                // Remaining space: (1600-1071)/2 = 264px top and bottom

                const centerX = this.gameWidth / 2;
                const bookScale = this.gameWidth / 1024; // 0.878
                const scaledBookHeight = 1220 * bookScale; // 1071px
                const bookY = this.gameHeight / 2; // Center the book
                const buttonSpacing = (this.gameHeight - scaledBookHeight) / 2; // 264px
                const storyButtonY = buttonSpacing / 2; // 132px from top
                const playButtonY = this.gameHeight - (buttonSpacing / 2); // 132px from bottom

                // Add cover image (scaled to fit canvas width)
                this.cover = this.add.image(centerX, bookY, 'cover_hedles');
                this.cover.setDisplaySize(this.gameWidth, scaledBookHeight);

                // Story button (in top area) - 512x256 ratio
                this.storyButton = this.add.image(centerX, storyButtonY, 'click_story');
                this.storyButton.setDisplaySize(256, 128);
                this.storyButton.setInteractive();
                this.storyButton.on('pointerover', () => {
                    this.storyButton.setTint(0xcccccc);
                });
                this.storyButton.on('pointerout', () => {
                    this.storyButton.setTint(0xffffff);
                });
                this.storyButton.on('pointerdown', () => {
                    this.buttonPress(this.storyButton, 'click_story2', 'StoryScreen');
                });

                // Play button (in bottom area) - 512x256 ratio
                this.playButton = this.add.image(centerX, playButtonY, 'click_play');
                this.playButton.setDisplaySize(256, 128);
                this.playButton.setInteractive();
                this.playButton.on('pointerover', () => {
                    this.playButton.setTint(0xcccccc);
                });
                this.playButton.on('pointerout', () => {
                    this.playButton.setTint(0xffffff);
                });
                this.playButton.on('pointerdown', () => {
                    this.buttonPress(this.playButton, 'click_play2', 'GameScreen');
                });

                // Keyboard support
                this.enterKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.ENTER);
                this.enterKey.on('down', () => {
                    this.buttonPress(this.playButton, 'click_play2', 'GameScreen');
                });
            }

            buttonPress(button, pressedTexture, targetScene) {
                // Play button sound
                if (this.cache.audio.exists('tap_button')) {
                    this.sound.play('tap_button');
                }

                // Briefly show pressed version
                const originalTexture = button.texture.key;
                button.setTexture(pressedTexture);

                this.time.delayedCall(150, () => {
                    button.setTexture(originalTexture);
                    this.time.delayedCall(50, () => {
                        this.scene.start(targetScene);
                    });
                });
            }
        }

        // Story Screen Scene
        class StoryScreen extends Phaser.Scene {
            constructor() {
                super({ key: 'StoryScreen' });
                this.gameWidth = 900;
                this.gameHeight = 1600;

                // Story text (themed around the game)
                this.storyLines = [
                    "In the mystical realm of Hedonia, where time flows like honey through ancient trees.",
                    "The peaceful Hedles lived in harmony, their round forms bobbing gently in meadows.",
                    "But darkness crept from the void, bringing with it an endless hunger.",
                    "Only the legendary cannon of the ancients could save them from certain doom.",
                    "You are the chosen guardian, wielder of heads and master of magical spells.",
                    "Will you defend the realm and protect the innocent Hedles from extinction?"
                ];

                this.currentLineIndex = 0;
                this.isTyping = false;
                this.canAdvance = false;
                this.typewriterSpeed = 50; // milliseconds per character
                this.typewriterSounds = []; // Will store multiple blip sounds
                this.fontLoaded = false; // Track font loading status
            }

            preload() {
                // Load story assets
                this.load.image('cover_secret', 'assets/cover_secret.jpg');
                this.load.image('text_background', 'assets/text_background.png');
                this.load.image('click_story', 'assets/click_story.png');
                this.load.image('click_story2', 'assets/click_story2.png');
                this.load.image('click_play', 'assets/click_play.png');
                this.load.image('click_play2', 'assets/click_play2.png');
                this.load.audio('tap_button', 'assets/tap_button.mp3');

                // Load typewriter sounds
                this.load.audio('type_blip1', 'assets/type_blip1.mp3');
                this.load.audio('type_blip2', 'assets/type_blip2.mp3');
                this.load.audio('type_blip3', 'assets/type_blip3.mp3');

                // Load the custom font using FontFace API - THE PROPER WAY
                this.load.addListener('complete', () => {
                    console.log('Assets loaded, now loading font...');

                    // Create FontFace instance for Press Start 2P
                    const fontFace = new FontFace('Press Start 2P', 'url(assets/PressStart2P-Regular.ttf)');

                    // Load the font
                    fontFace.load().then((loadedFont) => {
                        // Add to document fonts
                        document.fonts.add(loadedFont);
                        this.fontLoaded = true;
                        console.log('Font loaded successfully!');

                        // Verify the font is available
                        const fontAvailable = document.fonts.check('16px "Press Start 2P"');
                        console.log('Font available:', fontAvailable);

                        // Now we can safely create our story elements
                        this.createStoryElements();

                    }).catch((error) => {
                        console.error('Font failed to load:', error);
                        console.log('Falling back to monospace font');
                        this.fontLoaded = false;
                        this.createStoryElements();
                    });
                });

                // Error handlers
                this.load.on('loaderror', (file) => {
                    console.warn('Missing story asset:', file.key);
                    const graphics = this.make.graphics({ x: 0, y: 0, add: false });

                    if (file.key === 'cover_secret') {
                        graphics.fillStyle(0x1a1a2e, 1);
                        graphics.fillRect(0, 0, 1024, 1220);
                        graphics.fillStyle(0x666666, 1);
                        graphics.fillRect(400, 600, 224, 50);
                        graphics.generateTexture('cover_secret', 1024, 1220);
                    } else if (file.key === 'text_background') {
                        graphics.fillStyle(0x2c1810, 1);
                        graphics.fillRect(0, 0, 1024, 256);
                        graphics.lineStyle(4, 0x8b4513);
                        graphics.strokeRect(8, 8, 1008, 240);
                        graphics.generateTexture('text_background', 1024, 256);
                    } else if (file.key.startsWith('click_story') || file.key.startsWith('click_play')) {
                        const isGolden = file.key.includes('2');
                        graphics.fillStyle(0x444444, 1);
                        graphics.fillRect(0, 0, 512, 256);
                        graphics.fillStyle(isGolden ? 0xFFD700 : 0xffffff, 1);
                        graphics.fillRect(20, 50, 472, 156);
                        graphics.generateTexture(file.key, 512, 256);
                    }

                    graphics.destroy();
                });
            }

            create() {
                // Black background
                this.cameras.main.setBackgroundColor(0x000000);

                // Wait for font loading to complete before creating elements
                // The createStoryElements() will be called from the font loading callback
            }

            createStoryElements() {
                // Same layout calculations as StartScreen
                const centerX = this.gameWidth / 2;
                const bookScale = this.gameWidth / 1024; // 0.878
                const scaledBookHeight = 1220 * bookScale; // 1071px
                const bookY = this.gameHeight / 2; // Center the book
                const buttonSpacing = (this.gameHeight - scaledBookHeight) / 2; // 264px
                const storyButtonY = buttonSpacing / 2; // 132px from top
                const playButtonY = this.gameHeight - (buttonSpacing / 2); // 132px from bottom

                // Add secret cover image (same scaling)
                this.cover = this.add.image(centerX, bookY, 'cover_secret');
                this.cover.setDisplaySize(this.gameWidth, scaledBookHeight);

                // Story button (stays visible in story mode) - 512x256 ratio
                this.storyButton = this.add.image(centerX, storyButtonY, 'click_story');
                this.storyButton.setDisplaySize(256, 128);
                this.storyButton.setInteractive();
                this.storyButton.on('pointerover', () => {
                    this.storyButton.setTint(0xcccccc);
                });
                this.storyButton.on('pointerout', () => {
                    this.storyButton.setTint(0xffffff);
                });
                this.storyButton.on('pointerdown', () => {
                    this.buttonPress(this.storyButton, 'click_story2', 'StoryScreen');
                });

                // Play button (stays visible in story mode) - 512x256 ratio
                this.playButton = this.add.image(centerX, playButtonY, 'click_play');
                this.playButton.setDisplaySize(256, 128);
                this.playButton.setInteractive();
                this.playButton.on('pointerover', () => {
                    this.playButton.setTint(0xcccccc);
                });
                this.playButton.on('pointerout', () => {
                    this.playButton.setTint(0xffffff);
                });
                this.playButton.on('pointerdown', () => {
                    this.buttonPress(this.playButton, 'click_play2', 'GameScreen');
                });

                // Add text background INSIDE the cover area (bottom portion)
                const textBgScale = bookScale; // Same scale as book
                const textBgWidth = 1024 * textBgScale; // Scaled width
                const textBgHeight = 256 * textBgScale; // Scaled height
                const textBgY = bookY + (scaledBookHeight / 2) - (textBgHeight / 2) - 50; // Inside bottom of book

                this.textBackground = this.add.image(centerX, textBgY, 'text_background');
                this.textBackground.setDisplaySize(textBgWidth, textBgHeight);

                // Create text object for story - UPDATED MARGINS
                const textMarginX = textBgWidth * 0.1; // 10% margin from left (FIXED)
                const textMarginY = textBgHeight * 0.18; // 18% margin from top (FIXED)

                // Store the wrap width for later use
                this.textWrapWidth = textBgWidth - (textMarginX * 2);

                // Use properly quoted font name as required by Phaser
                const fontFamily = this.fontLoaded ? '"Press Start 2P"' : 'monospace';
                const fontSize = this.fontLoaded ? '28px' : '32px'; // Pixel fonts work best at certain sizes

                console.log('Creating text with font:', fontFamily, 'size:', fontSize);

                this.storyText = this.add.text(
                    centerX - (textBgWidth / 2) + textMarginX,
                    textBgY - (textBgHeight / 2) + textMarginY,
                    '',
                    {
                        fontFamily: fontFamily,
                        fontSize: fontSize,
                        fill: '#ffffff',
                        align: 'left',
                        // Start with word wrap enabled for initial setup
                        wordWrap: { width: this.textWrapWidth, useAdvancedWrap: true },
                        lineSpacing: 8
                    }
                );
                this.storyText.setOrigin(0, 0);

                // Add continue prompt (initially hidden)
                this.continuePrompt = this.add.text(centerX, textBgY + (textBgHeight / 2) + 40, 'Press SPACE or CLICK to continue...', {
                    fontFamily: fontFamily,
                    fontSize: this.fontLoaded ? '18px' : '20px',
                    fill: '#888888',
                    align: 'center'
                });
                this.continuePrompt.setOrigin(0.5);
                this.continuePrompt.setVisible(false);

                // Blinking effect for continue prompt
                this.tweens.add({
                    targets: this.continuePrompt,
                    alpha: 0.3,
                    duration: 800,
                    yoyo: true,
                    repeat: -1,
                    ease: 'Sine.easeInOut'
                });

                // Collect available typewriter sounds
                this.typewriterSounds = [];
                for (let i = 1; i <= 3; i++) {
                    if (this.cache.audio.exists(`type_blip${i}`)) {
                        this.typewriterSounds.push(`type_blip${i}`);
                    }
                }

                // Input handling
                this.input.on('pointerdown', () => {
                    this.handleAdvance();
                });

                this.spaceKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);
                this.spaceKey.on('down', () => {
                    this.handleAdvance();
                });

                this.escapeKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.ESC);
                this.escapeKey.on('down', () => {
                    this.scene.start('StartScreen');
                });

                // Start the first line
                this.showNextLine();
            }

            buttonPress(button, pressedTexture, targetScene) {
                // Play button sound
                if (this.cache.audio.exists('tap_button')) {
                    this.sound.play('tap_button');
                }

                // Briefly show pressed version
                const originalTexture = button.texture.key;
                button.setTexture(pressedTexture);

                this.time.delayedCall(150, () => {
                    button.setTexture(originalTexture);
                    this.time.delayedCall(50, () => {
                        this.scene.start(targetScene);
                    });
                });
            }

            handleAdvance() {
                if (this.isTyping) {
                    // Skip to end of current text
                    this.completeCurrentLine();
                } else if (this.canAdvance) {
                    // Go to next line
                    this.currentLineIndex++;
                    if (this.currentLineIndex >= this.storyLines.length) {
                        // Story finished, go to game
                        this.buttonPress(this.playButton, 'click_play2', 'GameScreen');
                    } else {
                        this.showNextLine();
                    }
                }
            }

            showNextLine() {
                if (this.currentLineIndex >= this.storyLines.length) return;

                this.isTyping = true;
                this.canAdvance = false;
                this.continuePrompt.setVisible(false);

                const fullText = this.storyLines[this.currentLineIndex];

                // MANUAL WORD WRAPPING CALCULATION
                const words = fullText.split(' ');
                const lines = [];
                let currentLine = '';

                // Create a temporary text object to measure word widths
                const measureText = this.add.text(0, 0, '', {
                    fontFamily: this.storyText.style.fontFamily,
                    fontSize: this.storyText.style.fontSize
                });

                for (let i = 0; i < words.length; i++) {
                    const word = words[i];
                    const testLine = currentLine ? `${currentLine} ${word}` : word;

                    // Measure the width of this test line
                    measureText.setText(testLine);
                    const lineWidth = measureText.width;

                    if (lineWidth <= this.textWrapWidth || currentLine === '') {
                        // Word fits on current line, OR this is the first word on a line (force it even if too long)
                        currentLine = testLine;
                    } else {
                        // Word doesn't fit, start new line
                        lines.push(currentLine);
                        currentLine = word;
                    }
                }

                // Add the last line if it exists
                if (currentLine) {
                    lines.push(currentLine);
                }

                measureText.destroy(); // Clean up

                // Join lines with newline characters
                const wrappedText = lines.join('\n');

                // STORE THE WRAPPED TEXT for use in completeCurrentLine()
                this.currentWrappedText = wrappedText;

                // DISABLE PHASER'S WORD WRAPPING since we're handling it manually
                this.storyText.setWordWrapWidth(0);

                // Now type the pre-wrapped text character by character
                let currentText = '';
                let charIndex = 0;

                this.storyText.setText('');

                const typeNextChar = () => {
                    if (charIndex < wrappedText.length && this.isTyping) {
                        currentText += wrappedText[charIndex];
                        this.storyText.setText(currentText);

                        // Play typewriter sound for visible characters (not spaces or newlines)
                        if (wrappedText[charIndex] !== ' ' && wrappedText[charIndex] !== '\n' && this.typewriterSounds.length > 0) {
                            const randomSound = Phaser.Utils.Array.GetRandom(this.typewriterSounds);
                            this.sound.play(randomSound, { volume: 0.3 });
                        }

                        charIndex++;
                        this.time.delayedCall(this.typewriterSpeed, typeNextChar);
                    } else {
                        this.completeCurrentLine();
                    }
                };

                typeNextChar();
            }

            completeCurrentLine() {
                this.isTyping = false;
                this.canAdvance = true;
                // Use the pre-wrapped text instead of the original text
                this.storyText.setText(this.currentWrappedText);
                this.continuePrompt.setVisible(true);
            }
        }

        // Game Screen Scene (existing HEDLES game logic)
        class GameScreen extends Phaser.Scene {
            constructor() {
                super({ key: 'GameScreen' });

                // Game configuration
                this.CANNON_SIZE = 96;
                this.CANNON_CHARGE_TIME = 500;
                this.CANNON_COOLDOWN_TIME = 1000; // 1 second
                this.HEAD_SIZE = 128;
                this.HEDLE_SIZE = 160;
                this.EGG_SIZE = 80; // Starting egg size
                this.HEAD_SPEED = 800;
                this.HEDLE_SPEED = 100;
                this.HEDLE_MOVE_TIME = 2000;
                this.HEDLE_WAIT_TIME = 1000;
                this.HEDLE_WALK_SPRITE_INTERVAL = 400;
                this.MINIMUM_SPAWN_DELAY = 500;
                this.EGG_GROWTH_TIME = 4000; // 4 seconds to hatch
                this.MIN_HEAD_DAMAGE_SPEED = 50; // Minimum speed to damage hedles
                this.BAT_SPEED = 200; // Speed of bat flying across screen
                this.SPELL_SLOT_SIZE = 120; // Size of spell UI slots (50% bigger)
                this.FIRE_EXPLOSION_RADIUS = 250; // Radius for fire spell (25% bigger)
                this.WATER_LINE_LENGTH = 3200; // Length of water spell line (much longer!)
                this.MULTI_SHOT_COUNT = 8; // Number of shots for multi spell
                this.MULTI_SHOT_DELAY = 250; // Delay between multi shots

                // Horse configuration
                this.HORSE_SIZE = 120; // Size of horse sprite
                this.HORSE_SPEED = 150; // Horse walking speed
                this.HORSE_WALK_FRAME_DURATION = 200; // Duration of each walk frame
                this.HORSE_LAY_FRAME_DURATION = 200; // Duration of each lay frame

                // Sprite counts
                this.HEAD_COUNT = 119;
                this.HEDLE_COUNT = 84;

                // Game dimensions
                this.gameWidth = 900;
                this.gameHeight = 1600;
            }

            init() {
                // Reset all game state on init (for proper restart)
                this.score = 0;
                this.gameOver = false;
                this.cannonAngle = -Math.PI / 2;
                this.cannonCharging = false;
                this.cannonOnCooldown = false;
                this.cannonChargeStart = 0;
                this.cannonCooldownStart = 0;
                this.lastPointerPosition = { x: 450, y: 400 };
                this.currentSpawnDelay = 4000;
                this.spawnSpeedMultiplier = 0.96;
                this.currentBatDelay = 8000; // First bat after 8 seconds
                this.batDelayIncrement = 200; // Add 200ms between each bat (should prevent infinite game)
                this.spellSlots = [null, null, null, null]; // 4 spell slots
                this.selectedSpell = null; // Currently selected spell
                this.isMultiShotting = false; // Track multi-shot state
                this.isFiring = false; // Track firing state
                this.shotQueued = false; // Track queued shots
                this.uiClickThisFrame = false; // Track UI clicks this frame
                this.scoreDigits = []; // Track score digit sprites
                this.DIGIT_SIZE = 96; // Height of each digit sprite (64x96)
                this.gameOverFadeOverlay = null; // Screen fade overlay
                this.currentFadeOpacity = 0; // Current screen fade opacity
                this.targetFadeOpacity = 0;  // Target screen fade opacity
                this.fadeTransitionSpeed = 1.0; // How fast to transition (higher = faster)

                // Horse state
                this.horse = null;
                this.horseWalkFrame = 0;
                this.horseIsLaying = false;
                this.horseAngle = 0; // Current movement direction in radians
                this.horseVelocityX = 0; // Current X velocity
                this.horseVelocityY = 0; // Current Y velocity
                this.pendingEggSpawn = false; // Flag to indicate an egg should be spawned
            }

            preload() {
                // Load cannon assets
                this.load.image('cannon', 'assets/cannon.png');
                this.load.audio('cannon_shot', 'assets/cannon_shot.mp3');

                // Load background music
                this.load.audio('hedles_music', 'assets/HEDLES.mp3');

                // Load background
                this.load.image('background', 'assets/background.png');

                // Load sound effects
                this.load.audio('oww_1', 'assets/oww_1.mp3');
                this.load.audio('oww_2', 'assets/oww_2.mp3');
                this.load.audio('oww_3', 'assets/oww_3.mp3');
                this.load.audio('oww_4', 'assets/oww_4.mp3');
                this.load.audio('pickup_spell', 'assets/pickup_spell.mp3');
                this.load.audio('ball_bounce', 'assets/ball_bounce.mp3');

                // Load egg sprite
                this.load.image('egg', 'assets/item_egg.png');

                // Load bat animation sprites
                this.load.image('bat_1', 'assets/bat_1.png');
                this.load.image('bat_2', 'assets/bat_2.png');
                this.load.image('bat_3', 'assets/bat_3.png');
                this.load.image('bat_4', 'assets/bat_4.png');

                // Load book sprites
                this.load.image('tome_fire', 'assets/tome_fire.png');
                this.load.image('tome_water', 'assets/tome_water.png');
                this.load.image('tome_storm', 'assets/tome_storm.png');
                this.load.image('tome_multi', 'assets/tome_multi.png');

                // Load spell interface icons
                this.load.image('icon_blank', 'assets/icon_blank.png');
                this.load.image('icon_fire', 'assets/icon_fire.png');
                this.load.image('icon_water', 'assets/icon_water.png');
                this.load.image('icon_storm', 'assets/icon_storm.png');
                this.load.image('icon_multi', 'assets/icon_multi.png');

                // Load spell effect sprites
                this.load.image('spell_fire', 'assets/spell_fire.png');
                this.load.image('spell_water', 'assets/spell_water.png');
                this.load.image('spell_storm', 'assets/spell_storm.png');
                this.load.image('spell_multi', 'assets/spell_multi.png');

                // Load digit sprites for score
                for (let i = 0; i <= 9; i++) {
                    this.load.image(`digit_${i}`, `assets/digit_${i}.png`);
                }

                // Load horse sprites
                for (let i = 1; i <= 8; i++) {
                    this.load.image(`horse_walk_${i}`, `assets/horse_walk_${i}.png`);
                }

                for (let i = 1; i <= 3; i++) {
                    this.load.image(`horse_egg_${i}`, `assets/horse_egg_${i}.png`);
                }

                // Add error handler for missing sprites
                this.load.on('loaderror', (file) => {
                    console.warn('Missing asset:', file.key);

                    // Create placeholders for missing assets
                    const graphics = this.make.graphics({ x: 0, y: 0, add: false });

                    if (file.key === 'background') {
                        graphics.fillStyle(0x2c3e50, 1);
                        graphics.fillRect(0, 0, 512, 512);
                        graphics.generateTexture('background', 512, 512);
                    } else if (file.key === 'egg') {
                        graphics.fillStyle(0xffffff, 1);
                        graphics.fillEllipse(32, 40, 64, 80);
                        graphics.generateTexture('egg', 64, 80);
                    } else if (file.key.startsWith('bat_')) {
                        graphics.fillStyle(0x444444, 1);
                        graphics.fillRect(0, 0, 120, 60);
                        graphics.generateTexture(file.key, 120, 60);
                    } else if (file.key.startsWith('tome_')) {
                        graphics.fillStyle(0x8B4513, 1);
                        graphics.fillRect(0, 0, 60, 80);
                        graphics.generateTexture(file.key, 60, 80);
                    } else if (file.key.startsWith('icon_')) {
                        graphics.fillStyle(0x666666, 1);
                        graphics.fillRect(0, 0, 80, 80);
                        graphics.generateTexture(file.key, 80, 80);
                    } else if (file.key.startsWith('spell_')) {
                        graphics.fillStyle(0xFF00FF, 1);
                        graphics.fillCircle(40, 40, 40);
                        graphics.generateTexture(file.key, 80, 80);
                    } else if (file.key.startsWith('digit_')) {
                        graphics.fillStyle(0xFFFFFF, 1);
                        graphics.fillRect(0, 0, 64, 96); // Correct 64x96 dimensions
                        // Add the digit number as simple text
                        const digitNum = file.key.split('_')[1];
                        graphics.fillStyle(0x000000, 1);
                        graphics.fillRect(20, 30, 24, 36);
                        graphics.generateTexture(file.key, 64, 96);
                    } else if (file.key.startsWith('horse_walk_')) {
                        graphics.fillStyle(0x8B4513, 1); // Brown for horse
                        graphics.fillRect(0, 0, 120, 80);
                        graphics.fillStyle(0x000000, 1);
                        graphics.fillRect(20, 60, 80, 20); // Legs
                        graphics.generateTexture(file.key, 120, 80);
                    } else if (file.key.startsWith('horse_egg_')) {
                        graphics.fillStyle(0x8B4513, 1); // Brown for horse
                        graphics.fillRect(0, 0, 120, 80);
                        graphics.fillStyle(0xFFFFFF, 1); // White for egg
                        graphics.fillEllipse(60, 70, 20, 15);
                        graphics.generateTexture(file.key, 120, 80);
                    }

                    graphics.destroy();
                });

                // Load head sprites
                for (let i = 1; i <= this.HEAD_COUNT; i++) {
                    const num = i.toString().padStart(4, '0');
                    this.load.image(`head_${num}`, `assets/head_${num}_ft.png`);
                }

                // Load hedle sprites
                for (let i = 1; i <= this.HEDLE_COUNT; i++) {
                    const num = i.toString().padStart(4, '0');
                    this.load.image(`body_${num}_ft`, `assets/body_${num}_ft.png`);
                    this.load.image(`body_${num}_bk`, `assets/body_${num}_bk.png`);
                    this.load.image(`body_${num}_L_sd`, `assets/body_${num}_L_sd.png`);
                    this.load.image(`body_${num}_R_sd`, `assets/body_${num}_R_sd.png`);
                }
            }

            create() {
                // Create golden dot texture for particles
                const graphics = this.make.graphics({ x: 0, y: 0, add: false });
                graphics.fillStyle(0xFFD700, 1);
                graphics.fillCircle(4, 4, 4);
                graphics.generateTexture('golden_dot', 8, 8);
                graphics.destroy();

                // Set background with tiled texture
                this.cameras.main.setBackgroundColor(0x2c3e50);

                // Tile the background texture
                const bgWidth = 900;
                const bgHeight = 1024;
                const tilesX = Math.ceil(this.gameWidth / bgWidth);
                const tilesY = Math.ceil(this.gameHeight / bgHeight);

                for (let x = 0; x < tilesX; x++) {
                    for (let y = 0; y < tilesY; y++) {
                        const bg = this.add.image(x * bgWidth, y * bgHeight, 'background');
                        bg.setOrigin(0, 0);
                        bg.setDepth(-10); // Put in background
                    }
                }

                // Set world bounds for physics
                this.physics.world.setBounds(0, 0, this.gameWidth, this.gameHeight);
                this.physics.world.setBoundsCollision(true, true, true, true);

                // Create physics groups
                this.hedles = this.physics.add.group();
                this.heads = this.physics.add.group();
                this.eggs = [];  // Track eggs manually (not physics objects)

                // Create cannon
                this.cannon = this.add.image(this.gameWidth / 2, this.gameHeight - 100, 'cannon');
                this.cannon.setDisplaySize(this.CANNON_SIZE, this.CANNON_SIZE * 2);
                this.cannon.setOrigin(0.5, 0.5);
                this.cannon.setDepth(200); // Above fade overlay

                // Create horse
                this.createHorse();

                // Set up collision detection with condition check
                this.physics.add.overlap(this.heads, this.hedles, this.hitHedle, this.canHitHedle, this);

                // Add head-to-head collisions for billiard physics, but exclude special heads
                this.physics.add.collider(this.heads, this.heads, this.headCollision, this.canHeadsCollide, this);

                // Create screen fade overlay for tension effect
                this.gameOverFadeOverlay = this.add.graphics();
                this.gameOverFadeOverlay.fillStyle(0x000000, 0);
                this.gameOverFadeOverlay.fillRect(0, 0, this.gameWidth, this.gameHeight);
                this.gameOverFadeOverlay.setDepth(50); // Below UI elements but above game objects

                // Input handling - HOLD TO FIRE SYSTEM
                this.input.removeAllListeners(); // Clear any existing listeners

                this.input.on('pointermove', (pointer) => {
                    this.lastPointerPosition = { x: pointer.x, y: pointer.y };
                    this.updateCannonAngle();
                });

                this.input.on('pointerdown', (pointer) => {
                    this.lastPointerPosition = { x: pointer.x, y: pointer.y };
                    this.updateCannonAngle();
                    // Only start firing if no UI was clicked this frame
                    if (!this.uiClickThisFrame) {
                        this.startFiring();
                    }
                });

                this.input.on('pointerup', () => {
                    this.stopFiring(); // Stop firing when released
                });

                // Keyboard support
                this.spaceKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);
                this.spaceKey.on('down', () => {
                    this.startFiring();
                });
                this.spaceKey.on('up', () => {
                    this.stopFiring();
                });

                // ESC to return to start screen
                this.escapeKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.ESC);
                this.escapeKey.on('down', () => {
                    // Stop background music before switching scenes
                    if (this.backgroundMusic && this.backgroundMusic.isPlaying) {
                        this.backgroundMusic.stop();
                    }
                    this.scene.start('StartScreen');
                });

                // Track firing state
                this.isFiring = false;

                // Initialize score display with 0
                this.updateScoreDisplay();

                // Create spell interface
                this.createSpellInterface();

                // Start spawning with first egg immediately
                this.triggerEggSpawn();
                this.scheduleNextEgg();

                // Schedule first bat
                this.scheduleBat();

                // Start background music
                if (this.cache.audio.exists('hedles_music')) {
                    this.backgroundMusic = this.sound.add('hedles_music', {
                        loop: true,
                        volume: 0.5
                    });
                    this.backgroundMusic.play();
                }
            }

            createHorse() {
                // Start horse in spawn area (where eggs used to spawn)
                const spawnX = Phaser.Math.Between(150, this.gameWidth - 150);
                const spawnY = Phaser.Math.Between(50, 150);

                this.horse = this.add.sprite(spawnX, spawnY, 'horse_walk_1');
                this.horse.setDisplaySize(this.HORSE_SIZE, this.HORSE_SIZE);
                this.horse.setDepth(100); // Above background, below UI

                // Horse movement state
                this.horseWalkFrame = 0;
                this.horseIsLaying = false;
                this.horseAngle = this.getRandomHorseDirection(); // Random initial direction
                this.horseVelocityX = Math.cos(this.horseAngle) * this.HORSE_SPEED;
                this.horseVelocityY = Math.sin(this.horseAngle) * this.HORSE_SPEED;

                // Start horse walking animation
                this.startHorseWalking();
            }

            getRandomHorseDirection() {
                // Pick either left or right direction, each with 45° spread
                const goingLeft = Phaser.Math.Between(0, 1) === 0;

                if (goingLeft) {
                    // Left direction: 180° ± 22.5° (157.5° to 202.5°)
                    return Phaser.Math.FloatBetween(157.5 * Math.PI / 180, 202.5 * Math.PI / 180);
                } else {
                    // Right direction: 0° ± 22.5° (-22.5° to 22.5°)
                    return Phaser.Math.FloatBetween(-22.5 * Math.PI / 180, 22.5 * Math.PI / 180);
                }
            }

            startHorseWalking() {
                // Start walking animation
                this.horseWalkTimer = this.time.addEvent({
                    delay: this.HORSE_WALK_FRAME_DURATION,
                    callback: () => {
                        if (!this.horseIsLaying && this.horse && this.horse.active) {
                            this.horseWalkFrame = (this.horseWalkFrame % 8) + 1;
                            this.horse.setTexture(`horse_walk_${this.horseWalkFrame}`);
                        }
                    },
                    loop: true
                });
            }

            updateHorseMovement() {
                if (!this.horse || !this.horse.active || this.horseIsLaying) return;

                // Move horse in current direction
                this.horse.x += this.horseVelocityX * (1 / 60); // Assuming 60 FPS
                this.horse.y += this.horseVelocityY * (1 / 60);

                // Keep horse within spawn area bounds and bounce off walls
                const margin = 60; // Keep horse away from edges
                let directionChanged = false;

                if (this.horse.x < margin) {
                    this.horse.x = margin;
                    this.horseVelocityX = Math.abs(this.horseVelocityX); // Bounce right
                    directionChanged = true;
                } else if (this.horse.x > this.gameWidth - margin) {
                    this.horse.x = this.gameWidth - margin;
                    this.horseVelocityX = -Math.abs(this.horseVelocityX); // Bounce left
                    directionChanged = true;
                }

                if (this.horse.y < 30) {
                    this.horse.y = 30;
                    this.horseVelocityY = Math.abs(this.horseVelocityY); // Bounce down
                    directionChanged = true;
                } else if (this.horse.y > 200) {
                    this.horse.y = 200;
                    this.horseVelocityY = -Math.abs(this.horseVelocityY); // Bounce up
                    directionChanged = true;
                }

                // Update angle if direction changed due to bouncing
                if (directionChanged) {
                    this.horseAngle = Math.atan2(this.horseVelocityY, this.horseVelocityX);
                }

                // Flip sprite based on direction (sprites are oriented left by default)
                // So flip when going right (positive X velocity)
                this.horse.setFlipX(this.horseVelocityX > 0);
            }

            triggerEggSpawn() {
                if (this.gameOver || !this.horse || !this.horse.active) return;

                // Set flag to spawn egg
                this.pendingEggSpawn = true;

                // Start laying animation
                this.startHorseLayingAnimation();
            }

            startHorseLayingAnimation() {
                if (this.horseIsLaying) return;

                this.horseIsLaying = true;

                // Stop walking animation
                if (this.horseWalkTimer) {
                    this.horseWalkTimer.paused = true;
                }

                let layFrame = 1;
                const layFrames = 3;

                // Animate through laying frames
                const layAnimation = () => {
                    if (layFrame <= layFrames && this.horse && this.horse.active) {
                        this.horse.setTexture(`horse_egg_${layFrame}`);

                        // Spawn egg on frame 2 (middle of animation)
                        if (layFrame === 2 && this.pendingEggSpawn) {
                            this.spawnEggAtHorse();
                            this.pendingEggSpawn = false;
                        }

                        layFrame++;

                        if (layFrame <= layFrames) {
                            this.time.delayedCall(this.HORSE_LAY_FRAME_DURATION, layAnimation);
                        } else {
                            // Animation complete, return to walking
                            this.endHorseLayingAnimation();
                        }
                    }
                };

                layAnimation();
            }

            endHorseLayingAnimation() {
                this.horseIsLaying = false;

                // Return to first walk frame
                this.horseWalkFrame = 1;
                if (this.horse && this.horse.active) {
                    this.horse.setTexture(`horse_walk_${this.horseWalkFrame}`);
                }

                // Pick a new random direction after laying egg
                this.horseAngle = this.getRandomHorseDirection();
                this.horseVelocityX = Math.cos(this.horseAngle) * this.HORSE_SPEED;
                this.horseVelocityY = Math.sin(this.horseAngle) * this.HORSE_SPEED;

                // Resume walking animation
                if (this.horseWalkTimer) {
                    this.horseWalkTimer.paused = false;
                }
            }

            spawnEggAtHorse() {
                if (this.gameOver || !this.horse || !this.horse.active) return;

                // Calculate egg position at horse's rear
                // Horse sprites are oriented left by default, so rear is to the right
                // If horse is flipped (facing right), rear is to the left
                const horseIsFlipped = this.horse.flipX;
                const rearOffsetDistance = 40; // Distance behind the horse

                let spawnX, spawnY;

                if (horseIsFlipped) {
                    // Horse facing right, rear is to the left
                    spawnX = this.horse.x - rearOffsetDistance;
                } else {
                    // Horse facing left, rear is to the right  
                    spawnX = this.horse.x + rearOffsetDistance;
                }

                spawnY = this.horse.y + 10; // Slightly below horse center

                // Clamp to valid spawn area
                spawnX = Phaser.Math.Clamp(spawnX, 150, this.gameWidth - 150);
                spawnY = Phaser.Math.Clamp(spawnY, 50, 200);

                const egg = this.add.sprite(spawnX, spawnY, 'egg');
                egg.setDisplaySize(this.EGG_SIZE, this.EGG_SIZE);

                // Store which hedle this will become
                egg.hedleId = Phaser.Math.Between(1, this.HEDLE_COUNT).toString().padStart(4, '0');
                egg.growthTimer = 0;

                // Add to eggs array for tracking
                this.eggs.push(egg);

                // Grow the egg over 4 seconds
                const growthSteps = 4;
                for (let i = 1; i <= growthSteps; i++) {
                    const timer = this.time.delayedCall(i * 1000, () => {
                        if (egg && egg.active && !this.gameOver) {
                            const newSize = this.EGG_SIZE * (1 + i * 0.25);
                            egg.setDisplaySize(newSize, newSize);

                            // Add pulsing effect as it grows
                            this.tweens.add({
                                targets: egg,
                                scaleX: egg.scaleX * 1.1,
                                scaleY: egg.scaleY * 1.1,
                                duration: 200,
                                yoyo: true,
                                ease: 'Sine.easeInOut'
                            });
                        }
                    });
                    egg[`growthTimer${i}`] = timer;
                }

                // Hatch after 4 seconds
                egg.hatchTimer = this.time.delayedCall(this.EGG_GROWTH_TIME, () => {
                    if (egg && egg.active && !this.gameOver) {
                        this.hatchEgg(egg);
                    }
                });
            }

            createSpellInterface() {
                this.spellIcons = [];
                const slotY = this.gameHeight - 100;
                const leftSlotX = [this.gameWidth / 2 - 280, this.gameWidth / 2 - 160]; // Spread wider
                const rightSlotX = [this.gameWidth / 2 + 160, this.gameWidth / 2 + 280]; // Spread wider

                // Create 4 spell slots
                for (let i = 0; i < 4; i++) {
                    const x = i < 2 ? leftSlotX[i] : rightSlotX[i - 2];

                    // Create blank icon
                    const icon = this.add.image(x, slotY, 'icon_blank');
                    icon.setDisplaySize(this.SPELL_SLOT_SIZE, this.SPELL_SLOT_SIZE);
                    icon.setInteractive();
                    icon.slotIndex = i;
                    icon.setDepth(200); // Above fade overlay

                    // Add selection border (hidden by default)
                    const border = this.add.graphics();
                    border.lineStyle(4, 0xFFD800);
                    border.strokeRect(
                        x - this.SPELL_SLOT_SIZE / 2,
                        slotY - this.SPELL_SLOT_SIZE / 2,
                        this.SPELL_SLOT_SIZE,
                        this.SPELL_SLOT_SIZE
                    );
                    border.setVisible(false);
                    border.setDepth(200); // Above fade overlay
                    icon.border = border;

                    // Handle clicking on spell slot
                    icon.on('pointerdown', () => {
                        if (!this.gameOver && !this.isMultiShotting) {
                            this.uiClickThisFrame = true; // Mark UI interaction
                            // Reset flag on next frame
                            this.time.delayedCall(10, () => {
                                this.uiClickThisFrame = false;
                            });

                            this.selectSpell(i);
                        }
                    });

                    this.spellIcons.push(icon);
                }
            }

            selectSpell(index) {
                if (!this.spellSlots[index]) return;

                // Stop firing when selecting a spell
                this.stopFiring();

                // Deselect all
                this.spellIcons.forEach(icon => {
                    icon.border.setVisible(false);
                });

                // Select this spell
                if (this.selectedSpell === index) {
                    this.selectedSpell = null; // Deselect if clicking same spell
                } else {
                    this.selectedSpell = index;
                    this.spellIcons[index].border.setVisible(true);
                }
            }

            addSpellToSlot(spellType) {
                // Find first empty slot
                const emptyIndex = this.spellSlots.indexOf(null);
                if (emptyIndex === -1) return false; // No empty slots

                // Add spell to slot
                this.spellSlots[emptyIndex] = spellType;
                this.spellIcons[emptyIndex].setTexture(`icon_${spellType}`);

                return true;
            }

            consumeSelectedSpell() {
                if (this.selectedSpell === null) return null;

                const spell = this.spellSlots[this.selectedSpell];
                if (!spell) return null;

                // Remove spell from slot
                this.spellSlots[this.selectedSpell] = null;
                this.spellIcons[this.selectedSpell].setTexture('icon_blank');
                this.spellIcons[this.selectedSpell].border.setVisible(false);

                const consumedSpell = spell;
                this.selectedSpell = null;

                return consumedSpell;
            }

            updateScoreDisplay() {
                // Clear existing digit sprites
                this.scoreDigits.forEach(digit => digit.destroy());
                this.scoreDigits = [];

                // Convert score to string to get individual digits
                const scoreStr = this.score.toString();
                const numDigits = scoreStr.length;

                // Calculate starting position for centering
                const digitWidth = 64; // Actual width of digit sprites
                const digitHeight = this.DIGIT_SIZE; // 96px height
                const totalWidth = numDigits * digitWidth;
                const startX = (this.gameWidth / 2) - (totalWidth / 2) + (digitWidth / 2);

                // Create sprite for each digit
                for (let i = 0; i < numDigits; i++) {
                    const digitValue = scoreStr[i];
                    const digitX = startX + (i * digitWidth);

                    const digitSprite = this.add.image(digitX, 60, `digit_${digitValue}`);
                    digitSprite.setDisplaySize(digitWidth, digitHeight);
                    digitSprite.setDepth(200); // Above fade overlay

                    this.scoreDigits.push(digitSprite);
                }
            }

            scheduleBat() {
                if (this.gameOver) return;

                this.batTimer = this.time.delayedCall(this.currentBatDelay, () => {
                    this.spawnBat();
                    // Increase delay for next bat
                    this.currentBatDelay += this.batDelayIncrement;
                    // Schedule next bat
                    this.scheduleBat();
                });
            }

            spawnBat() {
                if (this.gameOver) return;

                // Random Y position in middle 60% of screen
                const minY = this.gameHeight * 0.2;
                const maxY = this.gameHeight * 0.8;
                const batY = Phaser.Math.Between(minY, maxY);

                // Random direction
                const goingRight = Phaser.Math.Between(0, 1) === 1;
                const startX = goingRight ? -150 : this.gameWidth + 150; // Adjust for bigger bat
                const endX = goingRight ? this.gameWidth + 150 : -150;

                // Create bat
                const bat = this.add.sprite(startX, batY, 'bat_1');
                bat.setDisplaySize(180, 180); // 50% bigger
                bat.setDepth(300); // Always in front of darkness

                // Flip sprite if going left
                if (!goingRight) {
                    bat.setFlipX(true);
                }

                // Add golden particles around bat - RANDOM type for full area coverage
                const batParticles = this.add.particles(startX, batY, 'golden_dot', {
                    scale: { start: 0.6, end: 0.2 },
                    alpha: { start: 1.0, end: 0.2 },
                    speed: { min: 40, max: 80 },
                    lifespan: 2000,
                    frequency: 100,
                    quantity: 2,
                    emitZone: {
                        type: 'random',
                        source: new Phaser.Geom.Circle(0, 0, 64), // Random particles within 400px radius
                        quantity: 2
                    }
                });
                batParticles.setDepth(300); // Same as bat

                // Animate bat wings
                let batFrame = 0;
                const batFrames = ['bat_1', 'bat_2', 'bat_3', 'bat_4'];
                bat.animTimer = this.time.addEvent({
                    delay: 100,
                    callback: () => {
                        batFrame = (batFrame + 1) % 4;
                        bat.setTexture(batFrames[batFrame]);
                    },
                    loop: true
                });

                // Add random book
                const bookTypes = ['fire', 'water', 'storm', 'multi'];
                const bookType = Phaser.Utils.Array.GetRandom(bookTypes);
                const book = this.add.image(startX, batY + 60, `tome_${bookType}`); // Adjust offset for bigger bat
                book.setDisplaySize(90, 90); // 50% bigger
                book.setInteractive();
                book.bookType = bookType;
                book.setDepth(300); // Same as bat

                // Handle clicking on book
                book.on('pointerdown', () => {
                    this.uiClickThisFrame = true; // Mark UI interaction
                    // Reset flag on next frame
                    this.time.delayedCall(10, () => {
                        this.uiClickThisFrame = false;
                    });

                    if (this.addSpellToSlot(bookType)) {
                        // Play pickup sound
                        if (this.cache.audio.exists('pickup_spell')) {
                            this.sound.play('pickup_spell');
                        }

                        book.destroy();
                        // Visual feedback
                        const collected = this.add.text(book.x, book.y, `+${bookType.toUpperCase()}`, {
                            fontSize: '32px',
                            fill: '#FFD800'
                        }).setOrigin(0.5);

                        this.tweens.add({
                            targets: collected,
                            y: collected.y - 50,
                            alpha: 0,
                            duration: 1000,
                            onComplete: () => collected.destroy()
                        });
                    }
                });

                // Move bat across screen
                this.tweens.add({
                    targets: [bat, book, batParticles],
                    x: endX,
                    duration: this.gameWidth / this.BAT_SPEED * 1000,
                    onComplete: () => {
                        if (bat.animTimer) bat.animTimer.destroy();
                        bat.destroy();
                        if (book.active) book.destroy();
                        batParticles.destroy();
                    }
                });
            }

            startFiring() {
                if (this.gameOver) return;
                this.isFiring = true;
                this.attemptToFire();
            }

            stopFiring() {
                this.isFiring = false;
                // DON'T clear shotQueued here - let queued shots fire even after releasing click
            }

            attemptToFire() {
                if (!this.isFiring || this.gameOver || this.isMultiShotting) return;

                if (!this.cannonCharging && !this.cannonOnCooldown) {
                    this.startCannonCharge();
                } else {
                    // Queue up a shot if cannon is busy
                    this.shotQueued = true;
                }
            }

            startCannonCharge() {
                if (this.isMultiShotting) return;

                this.cannonCharging = true;
                this.cannonChargeStart = this.time.now;

                this.chargeTimer = this.time.delayedCall(this.CANNON_CHARGE_TIME, () => {
                    if (this.cannonCharging && !this.gameOver) {
                        this.fireCannon();
                    }
                });
            }

            fireCannon() {
                // Clear any queued shot since we're firing now
                this.shotQueued = false;

                // Check for multi-shot spell
                if (this.selectedSpell !== null && this.spellSlots[this.selectedSpell] === 'multi') {
                    const spell = this.consumeSelectedSpell();
                    if (spell) {
                        this.fireMultiShot();
                        return;
                    }
                }

                // Check for active spell
                const activeSpell = this.selectedSpell !== null ? this.spellSlots[this.selectedSpell] : null;

                // Play sound
                if (this.cache.audio.exists('cannon_shot')) {
                    this.sound.play('cannon_shot');
                }

                // Reset charging
                this.cannonCharging = false;
                this.cannon.setTint(0xffffff);

                // Start cooldown
                this.cannonOnCooldown = true;
                this.cannonCooldownStart = this.time.now;

                // Calculate head spawn position based on cannon angle
                const cannonLength = this.CANNON_SIZE;
                const spawnOffsetX = Math.cos(this.cannonAngle) * (cannonLength * 0.8);
                const spawnOffsetY = Math.sin(this.cannonAngle) * (cannonLength * 0.8);

                // Create head projectile
                const headNum = Phaser.Math.Between(1, this.HEAD_COUNT);
                const headId = headNum.toString().padStart(4, '0');

                const head = this.physics.add.sprite(
                    this.cannon.x + spawnOffsetX,
                    this.cannon.y + spawnOffsetY,
                    `head_${headId}`
                );

                // Add to group immediately
                this.heads.add(head);

                // Configure the sprite
                head.setDisplaySize(this.HEAD_SIZE, this.HEAD_SIZE);
                head.setOrigin(0.5, 0.25); // Perfect rotation around nose area

                // Set physics body
                head.body.setSize(18, 18);
                head.body.setOffset(16, 4);

                // Apply spell properties if active
                if (activeSpell) {
                    head.spellType = activeSpell;
                    head.hasHitHedle = false; // Track if special head has hit a hedle yet
                    this.consumeSelectedSpell();

                    if (activeSpell === 'storm') {
                        head.isPiercing = true;
                        // Add storm trail effect
                        this.addStormTrail(head);
                    } else {
                        // Enable bouncing for non-storm spells
                        head.body.setBounce(1, 1);
                    }

                    // Add spell visual to head
                    if (activeSpell !== 'storm') {
                        const spellVisual = this.add.image(head.x, head.y, `spell_${activeSpell}`);
                        spellVisual.setDisplaySize(80, 80);
                        head.spellVisual = spellVisual;
                    }
                } else {
                    // Enable bouncing for normal shots
                    head.body.setBounce(1, 1);
                }

                head.body.setDrag(0);

                // Calculate velocity
                const velocityX = Math.cos(this.cannonAngle) * this.HEAD_SPEED;
                const velocityY = Math.sin(this.cannonAngle) * this.HEAD_SPEED;

                // Set velocity
                head.body.velocity.set(velocityX, velocityY);
            }

            fireMultiShot() {
                this.isMultiShotting = true;
                this.shotQueued = false; // Clear any queued shot
                let shotCount = 0;

                const shootNext = () => {
                    if (shotCount >= this.MULTI_SHOT_COUNT || this.gameOver) {
                        this.isMultiShotting = false;
                        // No additional cooldown - cannon is ready to fire again immediately
                        return;
                    }

                    // Play sound
                    if (this.cache.audio.exists('cannon_shot')) {
                        this.sound.play('cannon_shot');
                    }

                    // Calculate head spawn position based on cannon angle
                    const cannonLength = this.CANNON_SIZE;
                    const spawnOffsetX = Math.cos(this.cannonAngle) * (cannonLength * 0.8);
                    const spawnOffsetY = Math.sin(this.cannonAngle) * (cannonLength * 0.8);

                    // Create head
                    const headNum = Phaser.Math.Between(1, this.HEAD_COUNT);
                    const headId = headNum.toString().padStart(4, '0');

                    const head = this.physics.add.sprite(
                        this.cannon.x + spawnOffsetX,
                        this.cannon.y + spawnOffsetY,
                        `head_${headId}`
                    );

                    this.heads.add(head);
                    head.setDisplaySize(this.HEAD_SIZE, this.HEAD_SIZE);
                    head.setOrigin(0.5, 0.25); // Perfect rotation around nose area
                    head.body.setSize(18, 18);
                    head.body.setOffset(16, 4); // Keep original physics body position
                    head.body.setBounce(1, 1);
                    head.body.setDrag(0);

                    // Mark as special multi-shot head
                    head.hasHitHedle = false; // Track if this multi head has hit a hedle yet

                    // Add multi spell visual
                    const spellVisual = this.add.image(head.x, head.y, 'spell_multi');
                    spellVisual.setDisplaySize(60, 60);
                    head.multiVisual = spellVisual;

                    // Fade visual over time
                    this.tweens.add({
                        targets: spellVisual,
                        alpha: 0,
                        duration: 1000,
                        onComplete: () => spellVisual.destroy()
                    });

                    // Set velocity
                    const velocityX = Math.cos(this.cannonAngle) * this.HEAD_SPEED;
                    const velocityY = Math.sin(this.cannonAngle) * this.HEAD_SPEED;
                    head.body.velocity.set(velocityX, velocityY);

                    shotCount++;

                    // Schedule next shot
                    this.time.delayedCall(this.MULTI_SHOT_DELAY, shootNext);
                };

                // Reset charging state before starting multi-shot
                this.cannonCharging = false;
                this.cannon.setTint(0xffffff);

                shootNext();
            }

            addStormTrail(head) {
                head.trailTimer = this.time.addEvent({
                    delay: 50,
                    callback: () => {
                        if (!head.active) {
                            head.trailTimer.destroy();
                            return;
                        }

                        const trail = this.add.image(head.x, head.y, 'spell_storm');
                        trail.setDisplaySize(60, 60);
                        trail.setAlpha(0.8);

                        this.tweens.add({
                            targets: trail,
                            alpha: 0,
                            duration: 500,
                            onComplete: () => trail.destroy()
                        });
                    },
                    loop: true
                });
            }

            executeFireSpell(x, y) {
                // Create circle of fire explosions
                const numExplosions = 16;
                for (let i = 0; i < numExplosions; i++) {
                    const angle = (i / numExplosions) * Math.PI * 2;
                    const explosionX = x + Math.cos(angle) * this.FIRE_EXPLOSION_RADIUS;
                    const explosionY = y + Math.sin(angle) * this.FIRE_EXPLOSION_RADIUS;

                    const explosion = this.add.image(explosionX, explosionY, 'spell_fire');
                    explosion.setDisplaySize(80, 80);

                    this.tweens.add({
                        targets: explosion,
                        alpha: 0,
                        scaleX: 1.5,
                        scaleY: 1.5,
                        duration: 1000,
                        onComplete: () => explosion.destroy()
                    });
                }

                // Kill all hedles in radius
                this.hedles.children.entries.forEach(hedle => {
                    if (!hedle.isDying) {
                        const distance = Phaser.Math.Distance.Between(x, y, hedle.x, hedle.y);
                        if (distance <= this.FIRE_EXPLOSION_RADIUS) {
                            this.killHedleBySpell(hedle);
                        }
                    }
                });
            }

            executeWaterSpell(x, y) {
                // Random angle for water line
                const angle = Phaser.Math.FloatBetween(0, Math.PI * 2);

                // Create water line visual with repeating wave pattern
                const numSegments = 40;
                const waveLength = 400; // Wave repeats every 400 pixels

                for (let i = 0; i < numSegments; i++) {
                    const segmentDist = (i / numSegments) * this.WATER_LINE_LENGTH - this.WATER_LINE_LENGTH / 2;
                    const waterX = x + Math.cos(angle) * segmentDist;
                    const waterY = y + Math.sin(angle) * segmentDist;

                    const water = this.add.image(waterX, waterY, 'spell_water');
                    water.setDisplaySize(60, 60);
                    water.setRotation(angle);

                    // Calculate wave phase based on position along line
                    const wavePhase = (Math.abs(segmentDist) % waveLength) / waveLength * Math.PI * 2;
                    const waveAmplitude = 25;
                    const waveFrequency = 800;

                    const perpAngle = angle + Math.PI / 2;
                    const startX = water.x;
                    const startY = water.y;

                    // Start wave motion immediately with different phase for each segment
                    this.tweens.add({
                        targets: water,
                        x: startX + Math.cos(perpAngle) * waveAmplitude,
                        y: startY + Math.sin(perpAngle) * waveAmplitude,
                        duration: waveFrequency / 2,
                        delay: wavePhase * 100, // Phase-based delay for wave pattern
                        yoyo: true,
                        repeat: 3, // More wave cycles
                        ease: 'Sine.easeInOut'
                    });

                    // Fade out
                    this.tweens.add({
                        targets: water,
                        alpha: 0,
                        duration: 2000,
                        onComplete: () => water.destroy()
                    });
                }

                // Kill hedles along the line
                this.hedles.children.entries.forEach(hedle => {
                    if (!hedle.isDying) {
                        // Calculate distance from hedle to line
                        const lineStart = {
                            x: x - Math.cos(angle) * this.WATER_LINE_LENGTH / 2,
                            y: y - Math.sin(angle) * this.WATER_LINE_LENGTH / 2
                        };
                        const lineEnd = {
                            x: x + Math.cos(angle) * this.WATER_LINE_LENGTH / 2,
                            y: y + Math.sin(angle) * this.WATER_LINE_LENGTH / 2
                        };

                        const distToLine = this.distanceToLine(hedle, lineStart, lineEnd);
                        if (distToLine <= 40) { // 40 pixel tolerance
                            this.killHedleBySpell(hedle);
                        }
                    }
                });
            }

            distanceToLine(point, lineStart, lineEnd) {
                const A = point.x - lineStart.x;
                const B = point.y - lineStart.y;
                const C = lineEnd.x - lineStart.x;
                const D = lineEnd.y - lineStart.y;

                const dot = A * C + B * D;
                const lenSq = C * C + D * D;
                let param = -1;

                if (lenSq !== 0) param = dot / lenSq;

                let xx, yy;

                if (param < 0) {
                    xx = lineStart.x;
                    yy = lineStart.y;
                } else if (param > 1) {
                    xx = lineEnd.x;
                    yy = lineEnd.y;
                } else {
                    xx = lineStart.x + param * C;
                    yy = lineStart.y + param * D;
                }

                const dx = point.x - xx;
                const dy = point.y - yy;

                return Math.sqrt(dx * dx + dy * dy);
            }

            killHedleBySpell(hedle) {
                if (hedle.isDying) return;

                hedle.isDying = true;

                // Play random oww sound
                const owwSounds = ['oww_1', 'oww_2', 'oww_3', 'oww_4'];
                const randomOww = Phaser.Utils.Array.GetRandom(owwSounds);
                if (this.cache.audio.exists(randomOww)) {
                    this.sound.play(randomOww);
                }

                // Clean up timers
                if (hedle.walkTimer) hedle.walkTimer.destroy();
                if (hedle.bobTween) hedle.bobTween.destroy();
                if (hedle.moveCycleTimer) hedle.moveCycleTimer.destroy();
                if (hedle.waitCycleTimer) hedle.waitCycleTimer.destroy();

                // Quick death for spell kills
                hedle.body.setVelocity(0, 0);
                hedle.body.enable = false;

                this.tweens.add({
                    targets: hedle,
                    alpha: 0,
                    scaleX: 0,
                    scaleY: 0,
                    duration: 500,
                    onComplete: () => hedle.destroy()
                });

                // Update score
                this.score++;
                this.updateScoreDisplay();
            }

            scheduleNextEgg() {
                if (this.gameOver) return;

                this.eggSpawnTimer = this.time.delayedCall(this.currentSpawnDelay, () => {
                    this.triggerEggSpawn();
                    // Make next spawn 10% faster
                    this.currentSpawnDelay *= this.spawnSpeedMultiplier;
                    // Minimum spawn delay
                    this.currentSpawnDelay = Math.max(this.MINIMUM_SPAWN_DELAY, this.currentSpawnDelay);
                    // Schedule next egg
                    this.scheduleNextEgg();
                });
            }

            hatchEgg(egg) {
                // Ensure hedle spawns within bounds
                const hedleX = Phaser.Math.Clamp(egg.x, 80, this.gameWidth - 80);
                const hedleY = Phaser.Math.Clamp(egg.y, 80, this.gameHeight - 200);

                const hedle = this.physics.add.sprite(hedleX, hedleY, `body_${egg.hedleId}_ft`);

                hedle.setDisplaySize(this.HEDLE_SIZE, this.HEDLE_SIZE);

                // Set physics body
                hedle.body.setSize(24, 32);
                hedle.body.setOffset(12, 16);

                // Set hedle to stay within screen bounds
                hedle.setCollideWorldBounds(true);
                hedle.body.setBounce(1, 1); // Full bounce off walls
                hedle.body.setMaxVelocity(this.HEDLE_SPEED, this.HEDLE_SPEED); // Cap maximum speed

                hedle.hedleId = egg.hedleId;
                hedle.currentSprite = 'ft';
                hedle.isDying = false;
                hedle.isMoving = false;
                hedle.walkSpriteIndex = 0;

                // Set initial direction
                hedle.direction = Phaser.Math.FloatBetween(Math.PI * 0.25, Math.PI * 0.75);

                // Add to group
                this.hedles.add(hedle);

                // Start animations
                this.createBobAnimation(hedle);
                this.startMovementCycle(hedle);

                // Remove egg from tracking array
                const index = this.eggs.indexOf(egg);
                if (index > -1) {
                    this.eggs.splice(index, 1);
                }

                // Destroy egg
                egg.destroy();
            }

            updateCannonAngle() {
                const cannonX = this.cannon.x;
                const cannonY = this.cannon.y;

                this.cannonAngle = Phaser.Math.Angle.Between(
                    cannonX, cannonY,
                    this.lastPointerPosition.x, this.lastPointerPosition.y
                );

                // Limit to upward 180° arc
                if (this.cannonAngle > 0) {
                    this.cannonAngle = 0;
                } else if (this.cannonAngle < -Math.PI) {
                    this.cannonAngle = -Math.PI;
                }

                this.cannon.setRotation(this.cannonAngle + Math.PI / 2);
            }

            createBobAnimation(hedle) {
                const currentScaleX = hedle.scaleX;
                const currentScaleY = hedle.scaleY;

                hedle.bobTween = this.tweens.add({
                    targets: hedle,
                    scaleY: currentScaleY * 1.02,
                    scaleX: currentScaleX * 0.98,
                    duration: 500,
                    yoyo: true,
                    repeat: -1,
                    ease: 'Sine.easeInOut'
                });
            }

            startMovementCycle(hedle) {
                if (hedle.isDying || !hedle.active) return;

                // Start moving phase
                hedle.isMoving = true;
                hedle.walkSpriteIndex = 0;

                // Pick new random direction
                hedle.direction = Phaser.Math.FloatBetween(Math.PI * 0.25, Math.PI * 0.75);

                // Set velocity
                const velX = Math.cos(hedle.direction) * this.HEDLE_SPEED;
                const velY = Math.sin(hedle.direction) * this.HEDLE_SPEED;
                hedle.body.setVelocity(velX, velY);

                // Animate walking sprites
                hedle.walkTimer = this.time.addEvent({
                    delay: this.HEDLE_WALK_SPRITE_INTERVAL,
                    callback: () => {
                        if (!hedle.isDying && hedle.active && hedle.isMoving) {
                            hedle.walkSpriteIndex = (hedle.walkSpriteIndex + 1) % 2;
                            const side = hedle.walkSpriteIndex === 0 ? 'L_sd' : 'R_sd';
                            hedle.setTexture(`body_${hedle.hedleId}_${side}`);
                        }
                    },
                    loop: true
                });

                // After move time, start waiting phase
                hedle.moveCycleTimer = this.time.delayedCall(this.HEDLE_MOVE_TIME, () => {
                    if (hedle.isDying || !hedle.active) return;

                    // Stop moving
                    hedle.isMoving = false;
                    hedle.body.setVelocity(0, 0);

                    // Clean up walk timer
                    if (hedle.walkTimer) hedle.walkTimer.destroy();

                    // Show front sprite
                    hedle.setTexture(`body_${hedle.hedleId}_ft`);

                    // After wait time, restart cycle
                    hedle.waitCycleTimer = this.time.delayedCall(this.HEDLE_WAIT_TIME, () => {
                        this.startMovementCycle(hedle);
                    });
                });
            }

            canHitHedle(head, hedle) {
                // Only hit if head is moving fast enough
                const speed = Math.sqrt(head.body.velocity.x ** 2 + head.body.velocity.y ** 2);
                return speed >= this.MIN_HEAD_DAMAGE_SPEED && !hedle.isDying;
            }

            hitHedle(head, hedle) {
                if (hedle.isDying) return;

                // Mark special heads as having hit a hedle (enables collisions with other heads)
                if (head.spellType || head.multiVisual) {
                    head.hasHitHedle = true;
                }

                // Check for spell effects
                if (head.spellType) {
                    if (head.spellType === 'fire') {
                        this.executeFireSpell(head.x, head.y);
                        // Clean up fire spell visual
                        if (head.spellVisual && head.spellVisual.active) {
                            head.spellVisual.destroy();
                        }
                    } else if (head.spellType === 'water') {
                        this.executeWaterSpell(head.x, head.y);
                        // Clean up water spell visual
                        if (head.spellVisual && head.spellVisual.active) {
                            head.spellVisual.destroy();
                        }
                    }
                    // Storm spell just pierces through

                    // Remove spell type after use (except storm which keeps piercing)
                    if (head.spellType !== 'storm') {
                        head.spellType = null;
                    }
                }

                hedle.isDying = true;

                // Play random oww sound
                const owwSounds = ['oww_1', 'oww_2', 'oww_3', 'oww_4'];
                const randomOww = Phaser.Utils.Array.GetRandom(owwSounds);
                if (this.cache.audio.exists(randomOww)) {
                    this.sound.play(randomOww);
                }

                // Clean up timers
                if (hedle.walkTimer) hedle.walkTimer.destroy();
                if (hedle.bobTween) hedle.bobTween.destroy();
                if (hedle.moveCycleTimer) hedle.moveCycleTimer.destroy();
                if (hedle.waitCycleTimer) hedle.waitCycleTimer.destroy();

                // Death animation - rotate around feet
                hedle.body.setVelocity(0, 0);
                hedle.body.enable = false; // Disable physics to prevent further collisions

                // Store current position before changing origin
                const currentY = hedle.y;

                // Change origin to bottom center for rotation
                hedle.setOrigin(0.5, 1);

                // Adjust position to compensate for origin change
                // When origin changes from center to bottom, we need to move sprite down
                hedle.y = currentY + (hedle.displayHeight / 2);

                // Randomly fall left or right
                const fallDirection = Phaser.Math.Between(0, 1) === 0 ? -1 : 1;

                this.tweens.add({
                    targets: hedle,
                    rotation: (Math.PI / 2) * fallDirection,
                    alpha: 0,
                    duration: 1000,
                    onComplete: () => hedle.destroy()
                });

                // Update score
                this.score++;
                this.updateScoreDisplay();

                // Bounce head (except storm which pierces)
                if (!head.isPiercing) {
                    // Reduce speed by half
                    const currentSpeed = Math.sqrt(head.body.velocity.x ** 2 + head.body.velocity.y ** 2);
                    const newSpeed = currentSpeed * 0.5;
                    const bounceAngle = Phaser.Math.FloatBetween(0, Math.PI * 2);
                    const newVelX = Math.cos(bounceAngle) * newSpeed;
                    const newVelY = Math.sin(bounceAngle) * newSpeed;
                    head.body.setVelocity(newVelX, newVelY);
                }
            }

            headCollision(head1, head2) {
                // Play ball bounce sound
                if (this.cache.audio.exists('ball_bounce')) {
                    this.sound.play('ball_bounce');
                }
                // Billiard-style collision already handled by Phaser's physics
                // No damping - keep full velocity
            }

            canHeadsCollide(head1, head2) {
                // Check if heads are special (have spell properties or multi visual)
                const head1IsSpecial = head1.spellType || head1.multiVisual;
                const head2IsSpecial = head2.spellType || head2.multiVisual;

                // If both heads are normal, they can collide
                if (!head1IsSpecial && !head2IsSpecial) {
                    return true;
                }

                // Storm spells never collide (keep piercing forever)
                if ((head1IsSpecial && head1.spellType === 'storm') ||
                    (head2IsSpecial && head2.spellType === 'storm')) {
                    return false;
                }

                // If either non-storm special head hasn't hit a hedle yet, no collision
                if (head1IsSpecial && head1.hasHitHedle === false) {
                    return false;
                }
                if (head2IsSpecial && head2.hasHitHedle === false) {
                    return false;
                }

                // If we get here, any special heads involved have already hit hedles
                // So they can now collide normally
                return true;
            }

            checkGameOver() {
                this.hedles.children.entries.forEach(hedle => {
                    if (!hedle.isDying && hedle.y > this.gameHeight - 160) {
                        this.endGame();
                    }
                });
            }

            updateScreenFade(delta) {
                if (!this.gameOverFadeOverlay) return;

                let maxThreatLevel = 0;

                // Check all hedles for proximity to bottom
                this.hedles.children.entries.forEach(hedle => {
                    if (!hedle.isDying) {
                        const threatZoneStart = this.gameHeight * 0.2; // Lower 80% of screen
                        const gameOverZone = this.gameHeight - 160; // Game over line

                        if (hedle.y > threatZoneStart) {
                            // Calculate threat level (0 to 1)
                            const threatLevel = Math.min((hedle.y - threatZoneStart) / (gameOverZone - threatZoneStart), 1);
                            maxThreatLevel = Math.max(maxThreatLevel, threatLevel);
                        }
                    }
                });

                // Set target fade opacity based on max threat level (0 to 80% opacity)
                this.targetFadeOpacity = maxThreatLevel * 0.8;

                // Smoothly interpolate current opacity towards target
                const deltaSeconds = delta * 0.001; // Convert delta to seconds
                const transitionAmount = this.fadeTransitionSpeed * deltaSeconds;

                if (this.currentFadeOpacity < this.targetFadeOpacity) {
                    // Darkening - can be slightly faster for tension
                    this.currentFadeOpacity = Math.min(
                        this.currentFadeOpacity + transitionAmount * 1.2,
                        this.targetFadeOpacity
                    );
                } else if (this.currentFadeOpacity > this.targetFadeOpacity) {
                    // Lightening - can be slightly slower for relief
                    this.currentFadeOpacity = Math.max(
                        this.currentFadeOpacity - transitionAmount * 0.8,
                        this.targetFadeOpacity
                    );
                }

                // Clear and redraw the graphics with smoothed alpha
                this.gameOverFadeOverlay.clear();
                if (this.currentFadeOpacity > 0) {
                    this.gameOverFadeOverlay.fillStyle(0x000000, this.currentFadeOpacity);
                    this.gameOverFadeOverlay.fillRect(0, 0, this.gameWidth, this.gameHeight);
                }
            }

            endGame() {
                if (this.gameOver) return; // Prevent multiple calls

                this.gameOver = true;
                this.stopFiring(); // Stop manual firing

                // Stop background music
                if (this.backgroundMusic && this.backgroundMusic.isPlaying) {
                    this.backgroundMusic.stop();
                }

                // Don't change screen fade - let it stay at current level (max 0.8 opacity)

                // Clean up all timers
                if (this.eggSpawnTimer) this.eggSpawnTimer.destroy();
                if (this.chargeTimer) this.chargeTimer.destroy();
                if (this.batTimer) this.batTimer.destroy();
                if (this.horseWalkTimer) this.horseWalkTimer.destroy();

                // Stop horse movement and animation (but keep it visible)
                if (this.horse && this.horse.active) {
                    this.horseVelocityX = 0;
                    this.horseVelocityY = 0;
                    this.horseIsLaying = false;
                }

                // Stop all hedles
                this.hedles.children.entries.forEach(hedle => {
                    if (hedle.body) hedle.body.setVelocity(0, 0);
                    if (hedle.walkTimer) hedle.walkTimer.destroy();
                    if (hedle.bobTween) hedle.bobTween.destroy();
                    if (hedle.moveCycleTimer) hedle.moveCycleTimer.destroy();
                    if (hedle.waitCycleTimer) hedle.waitCycleTimer.destroy();
                });

                // Clean up all eggs
                this.eggs.forEach(egg => {
                    // Cancel all growth timers
                    for (let i = 1; i <= 4; i++) {
                        if (egg[`growthTimer${i}`]) egg[`growthTimer${i}`].destroy();
                    }
                    if (egg.hatchTimer) egg.hatchTimer.destroy();
                    egg.destroy();
                });
                this.eggs = [];

                // Clean up all heads with spell visuals
                this.heads.children.entries.forEach(head => {
                    this.cleanupHead(head);
                });

                // Hide spell interface
                if (this.spellIcons) {
                    this.spellIcons.forEach(icon => {
                        icon.setVisible(false);
                        if (icon.border) icon.border.setVisible(false);
                    });
                }

                // Hide score digits
                this.scoreDigits.forEach(digit => digit.setVisible(false));

                this.add.text(this.gameWidth / 2, this.gameHeight / 2, 'GAME OVER', {
                    fontSize: '96px',
                    fill: '#ff0000'
                }).setOrigin(0.5).setDepth(200); // Above fade overlay

                // Add play again button
                const playAgainButton = this.add.text(this.gameWidth / 2, this.gameHeight / 2 + 120, 'PLAY AGAIN', {
                    fontSize: '48px',
                    fill: '#00ff00',
                    backgroundColor: '#000000',
                    padding: { x: 20, y: 10 }
                }).setOrigin(0.5).setDepth(200); // Above fade overlay

                playAgainButton.setInteractive();
                playAgainButton.on('pointerover', () => {
                    playAgainButton.setScale(1.1);
                    playAgainButton.setFill('#ffffff');
                });
                playAgainButton.on('pointerout', () => {
                    playAgainButton.setScale(1);
                    playAgainButton.setFill('#00ff00');
                });
                playAgainButton.on('pointerdown', () => {
                    this.scene.restart();
                });
            }

            update(time, delta) {
                if (this.gameOver) return;

                // Update horse movement
                this.updateHorseMovement();

                // Update cooldown and manual firing
                if (this.cannonOnCooldown) {
                    const elapsed = this.time.now - this.cannonCooldownStart;
                    if (elapsed >= this.CANNON_COOLDOWN_TIME) {
                        this.cannonOnCooldown = false;
                        // Handle queued shots first, then continued firing
                        if (this.shotQueued && !this.isMultiShotting) {
                            this.shotQueued = false; // Clear the queue
                            this.startCannonCharge(); // Fire the queued shot directly
                        } else if (this.isFiring && !this.isMultiShotting) {
                            this.attemptToFire(); // Continue hold-to-fire
                        }
                    }
                }

                // Cannon charging animation - restored!
                if (this.cannonCharging) {
                    const chargeProgress = (this.time.now - this.cannonChargeStart) / this.CANNON_CHARGE_TIME;
                    const shakeIntensity = Math.min(chargeProgress * 10, 10);

                    this.cannon.x = this.gameWidth / 2 + (Math.random() - 0.5) * shakeIntensity;
                    this.cannon.y = this.gameHeight - 100 + (Math.random() - 0.5) * shakeIntensity;
                    this.cannon.setTint(0xff4444); // Red charging tint
                } else {
                    this.cannon.x = this.gameWidth / 2;
                    this.cannon.y = this.gameHeight - 100;

                    // Tint cannon based on selected spell
                    if (this.selectedSpell !== null && this.spellSlots[this.selectedSpell]) {
                        const spellType = this.spellSlots[this.selectedSpell];
                        if (spellType === 'fire') {
                            this.cannon.setTint(0xff6600); // Orange for fire
                        } else if (spellType === 'water') {
                            this.cannon.setTint(0x0099ff); // Blue for water
                        } else if (spellType === 'storm') {
                            this.cannon.setTint(0x9900ff); // Purple for storm
                        } else if (spellType === 'multi') {
                            this.cannon.setTint(0x00ff00); // Green for multi
                        }
                    } else {
                        this.cannon.setTint(0xffffff);
                    }
                }

                // Update spell visuals to follow heads and rotate heads based on velocity
                this.heads.children.entries.forEach(head => {
                    if (head.spellVisual && head.spellVisual.active) {
                        head.spellVisual.x = head.x;
                        head.spellVisual.y = head.y;
                    }
                    if (head.multiVisual && head.multiVisual.active) {
                        head.multiVisual.x = head.x;
                        head.multiVisual.y = head.y;
                    }

                    // Rotate head based on velocity around center
                    if (head.body) {
                        const speed = Math.sqrt(head.body.velocity.x ** 2 + head.body.velocity.y ** 2);
                        const rotationSpeed = speed * 0.008; // Adjust rotation multiplier
                        head.rotation += rotationSpeed * delta * 0.001;
                    }
                });

                // Screen fade effect based on hedle proximity to bottom (now with smooth transitions)
                this.updateScreenFade(delta);

                // Keep hedles within bounds
                this.hedles.children.entries.forEach(hedle => {
                    if (!hedle.isDying && hedle.isMoving) {
                        // Clamp position to screen bounds
                        if (hedle.x < 40) {
                            hedle.x = 40;
                            hedle.body.setVelocityX(Math.abs(hedle.body.velocity.x));
                        } else if (hedle.x > this.gameWidth - 40) {
                            hedle.x = this.gameWidth - 40;
                            hedle.body.setVelocityX(-Math.abs(hedle.body.velocity.x));
                        }

                        if (hedle.y < 40) {
                            hedle.y = 40;
                            hedle.body.setVelocityY(Math.abs(hedle.body.velocity.y));
                        }
                    }
                });

                // Clean up off-screen heads only
                this.heads.children.entries.forEach(head => {
                    if (head.x < -200 || head.x > this.gameWidth + 200 ||
                        head.y < -200 || head.y > this.gameHeight + 200) {
                        this.cleanupHead(head);
                    }
                });

                this.checkGameOver();
            }

            cleanupHead(head) {
                if (head.trailTimer) head.trailTimer.destroy();
                if (head.spellVisual && head.spellVisual.active) head.spellVisual.destroy();
                if (head.multiVisual && head.multiVisual.active) head.multiVisual.destroy();
                head.destroy();
            }
        }

        // Game configuration
        const config = {
            type: Phaser.AUTO,
            width: 900,
            height: 1600,
            parent: 'game-container',
            physics: {
                default: 'arcade',
                arcade: {
                    gravity: { y: 0 },
                    debug: false
                }
            },
            scene: [StartScreen, StoryScreen, GameScreen],
            scale: {
                mode: Phaser.Scale.FIT,
                autoCenter: Phaser.Scale.CENTER_BOTH
            }
        };

        const game = new Phaser.Game(config);
    </script>
</body>

</html>