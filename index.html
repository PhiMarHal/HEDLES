<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>HEDLES</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/phaser/3.70.0/phaser.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100vh;
            background: #1a1a2e;
            font-family: Arial, sans-serif;
            touch-action: none;
            overflow: hidden;
            position: fixed;
            top: 0;
            left: 0;
        }

        html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
        }
    </style>
</head>

<body>
    <div id="game-container"></div>

    <script>
        class HEDLES extends Phaser.Scene {
            constructor() {
                super({ key: 'HEDLES' });

                // Game configuration
                this.CANNON_SIZE = 96;
                this.CANNON_CHARGE_TIME = 500;
                this.CANNON_COOLDOWN_TIME = 1000;
                this.HEAD_SIZE = 128;
                this.HEDLE_SIZE = 160;
                this.EGG_SIZE = 80; // Starting egg size
                this.HEAD_SPEED = 800;
                this.HEDLE_SPEED = 75;
                this.HEDLE_MOVE_TIME = 2000;
                this.HEDLE_WAIT_TIME = 2000;
                this.HEDLE_WALK_SPRITE_INTERVAL = 400;
                this.EGG_GROWTH_TIME = 4000; // 4 seconds to hatch
                this.MIN_HEAD_DAMAGE_SPEED = 50; // Minimum speed to damage hedles

                // Sprite counts
                this.HEAD_COUNT = 4;
                this.HEDLE_COUNT = 4;

                // Game dimensions
                this.gameWidth = 900;
                this.gameHeight = 1600;
            }

            init() {
                // Reset all game state on init (for proper restart)
                this.score = 0;
                this.gameOver = false;
                this.cannonAngle = -Math.PI / 2;
                this.cannonCharging = false;
                this.cannonOnCooldown = false;
                this.cannonChargeStart = 0;
                this.cannonCooldownStart = 0;
                this.lastPointerPosition = { x: 450, y: 400 };
                this.currentSpawnDelay = 4000; // Start with 4 second delay
                this.spawnSpeedMultiplier = 0.9; // Make 10% faster each time
                this.isFiring = false; // Reset firing state
            }

            preload() {
                // Load cannon assets
                this.load.image('cannon', 'assets/cannon.png');
                this.load.audio('cannon_shot', 'assets/cannon_shot.mp3');

                // Load egg sprite (create placeholder if missing)
                this.load.image('egg', 'assets/item_egg.png');

                // Add error handler for missing egg sprite
                this.load.on('loaderror', (file) => {
                    if (file.key === 'egg') {
                        // Create white oval placeholder for egg
                        const graphics = this.make.graphics({ x: 0, y: 0, add: false });
                        graphics.fillStyle(0xffffff, 1);
                        graphics.fillEllipse(32, 40, 64, 80);
                        graphics.generateTexture('egg', 64, 80);
                        graphics.destroy();
                    }
                });

                // Load head sprites
                for (let i = 1; i <= this.HEAD_COUNT; i++) {
                    const num = i.toString().padStart(4, '0');
                    this.load.image(`head_${num}`, `assets/head_${num}_ft.png`);
                }

                // Load hedle sprites
                for (let i = 1; i <= this.HEDLE_COUNT; i++) {
                    const num = i.toString().padStart(4, '0');
                    this.load.image(`body_${num}_ft`, `assets/body_${num}_ft.png`);
                    this.load.image(`body_${num}_bk`, `assets/body_${num}_bk.png`);
                    this.load.image(`body_${num}_L_sd`, `assets/body_${num}_L_sd.png`);
                    this.load.image(`body_${num}_R_sd`, `assets/body_${num}_R_sd.png`);
                }
            }

            create() {
                // Set background
                this.cameras.main.setBackgroundColor(0x2c3e50);

                // Set world bounds for physics
                this.physics.world.setBounds(0, 0, this.gameWidth, this.gameHeight);
                this.physics.world.setBoundsCollision(true, true, true, true);

                // Create physics groups
                this.hedles = this.physics.add.group();
                this.heads = this.physics.add.group();
                this.eggs = [];  // Track eggs manually (not physics objects)

                // Create cannon
                this.cannon = this.add.image(this.gameWidth / 2, this.gameHeight - 100, 'cannon');
                this.cannon.setDisplaySize(this.CANNON_SIZE, this.CANNON_SIZE * 2);
                this.cannon.setOrigin(0.5, 0.5);

                // Set up collision detection with condition check
                this.physics.add.overlap(this.heads, this.hedles, this.hitHedle, this.canHitHedle, this);

                // Add head-to-head collisions for billiard physics
                this.physics.add.collider(this.heads, this.heads, this.headCollision, null, this);

                // Input handling
                this.input.removeAllListeners(); // Clear any existing listeners

                this.input.on('pointermove', (pointer) => {
                    this.lastPointerPosition = { x: pointer.x, y: pointer.y };
                    this.updateCannonAngle();
                });

                this.input.on('pointerdown', (pointer) => {
                    this.lastPointerPosition = { x: pointer.x, y: pointer.y };
                    this.updateCannonAngle();
                    this.startFiring();
                });

                this.input.on('pointerup', () => {
                    this.stopFiring();
                });

                // Keyboard support
                this.spaceKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);
                this.spaceKey.on('down', () => {
                    this.startFiring();
                });
                this.spaceKey.on('up', () => {
                    this.stopFiring();
                });

                // Track firing state
                this.isFiring = false;

                // Score text
                this.scoreText = this.add.text(this.gameWidth / 2, 50, 'Score: 0', {
                    fontSize: '48px',
                    fill: '#ffffff'
                }).setOrigin(0.5);

                // Start spawning with first egg immediately
                this.spawnEgg();
                this.scheduleNextEgg();
            }

            scheduleNextEgg() {
                if (this.gameOver) return;

                this.eggSpawnTimer = this.time.delayedCall(this.currentSpawnDelay, () => {
                    this.spawnEgg();
                    // Make next spawn 10% faster
                    this.currentSpawnDelay *= this.spawnSpeedMultiplier;
                    // Minimum spawn delay of 500ms
                    this.currentSpawnDelay = Math.max(500, this.currentSpawnDelay);
                    // Schedule next egg
                    this.scheduleNextEgg();
                });
            }

            spawnEgg() {
                if (this.gameOver) return;

                const spawnX = Phaser.Math.Between(150, this.gameWidth - 150); // Keep away from edges
                const spawnY = Phaser.Math.Between(50, 150); // Random Y near top

                const egg = this.add.sprite(spawnX, spawnY, 'egg');
                egg.setDisplaySize(this.EGG_SIZE, this.EGG_SIZE);

                // Store which hedle this will become
                egg.hedleId = Phaser.Math.Between(1, this.HEDLE_COUNT).toString().padStart(4, '0');
                egg.growthTimer = 0;

                // Add to eggs array for tracking
                this.eggs.push(egg);

                // Grow the egg over 4 seconds
                const growthSteps = 4;
                for (let i = 1; i <= growthSteps; i++) {
                    const timer = this.time.delayedCall(i * 1000, () => {
                        if (egg && egg.active && !this.gameOver) {
                            const newSize = this.EGG_SIZE * (1 + i * 0.25);
                            egg.setDisplaySize(newSize, newSize);

                            // Add pulsing effect as it grows
                            this.tweens.add({
                                targets: egg,
                                scaleX: egg.scaleX * 1.1,
                                scaleY: egg.scaleY * 1.1,
                                duration: 200,
                                yoyo: true,
                                ease: 'Sine.easeInOut'
                            });
                        }
                    });
                    egg[`growthTimer${i}`] = timer;
                }

                // Hatch after 4 seconds
                egg.hatchTimer = this.time.delayedCall(this.EGG_GROWTH_TIME, () => {
                    if (egg && egg.active && !this.gameOver) {
                        this.hatchEgg(egg);
                    }
                });
            }

            hatchEgg(egg) {
                // Ensure hedle spawns within bounds
                const hedleX = Phaser.Math.Clamp(egg.x, 80, this.gameWidth - 80);
                const hedleY = Phaser.Math.Clamp(egg.y, 80, this.gameHeight - 200);

                const hedle = this.physics.add.sprite(hedleX, hedleY, `body_${egg.hedleId}_ft`);

                hedle.setDisplaySize(this.HEDLE_SIZE, this.HEDLE_SIZE);

                // Set physics body
                hedle.body.setSize(24, 32);
                hedle.body.setOffset(12, 16);

                // Set hedle to stay within screen bounds
                hedle.setCollideWorldBounds(true);
                hedle.body.setBounce(1, 1); // Full bounce off walls
                hedle.body.setMaxVelocity(this.HEDLE_SPEED, this.HEDLE_SPEED); // Cap maximum speed

                hedle.hedleId = egg.hedleId;
                hedle.currentSprite = 'ft';
                hedle.isDying = false;
                hedle.isMoving = false;
                hedle.walkSpriteIndex = 0;

                // Set initial direction
                hedle.direction = Phaser.Math.FloatBetween(Math.PI * 0.25, Math.PI * 0.75);

                // Add to group
                this.hedles.add(hedle);

                // Start animations
                this.createBobAnimation(hedle);
                this.startMovementCycle(hedle);

                // Remove egg from tracking array
                const index = this.eggs.indexOf(egg);
                if (index > -1) {
                    this.eggs.splice(index, 1);
                }

                // Destroy egg
                egg.destroy();
            }

            updateCannonAngle() {
                const cannonX = this.cannon.x;
                const cannonY = this.cannon.y;

                this.cannonAngle = Phaser.Math.Angle.Between(
                    cannonX, cannonY,
                    this.lastPointerPosition.x, this.lastPointerPosition.y
                );

                // Limit to upward 180° arc
                if (this.cannonAngle > 0) {
                    this.cannonAngle = 0;
                } else if (this.cannonAngle < -Math.PI) {
                    this.cannonAngle = -Math.PI;
                }

                this.cannon.setRotation(this.cannonAngle + Math.PI / 2);
            }

            startFiring() {
                if (this.gameOver) return;
                this.isFiring = true;
                this.attemptToFire();
            }

            stopFiring() {
                this.isFiring = false;
            }

            attemptToFire() {
                if (!this.isFiring || this.gameOver) return;

                if (!this.cannonCharging && !this.cannonOnCooldown) {
                    this.startCannonCharge();
                }
            }

            startCannonCharge() {
                this.cannonCharging = true;
                this.cannonChargeStart = this.time.now;

                this.chargeTimer = this.time.delayedCall(this.CANNON_CHARGE_TIME, () => {
                    if (this.cannonCharging && !this.gameOver) {
                        this.fireCannon();
                    }
                });
            }

            fireCannon() {
                // Play sound
                if (this.cache.audio.exists('cannon_shot')) {
                    this.sound.play('cannon_shot');
                }

                // Reset charging
                this.cannonCharging = false;
                this.cannon.setTint(0xffffff);

                // Start cooldown
                this.cannonOnCooldown = true;
                this.cannonCooldownStart = this.time.now;

                // Create head projectile
                const headNum = Phaser.Math.Between(1, this.HEAD_COUNT);
                const headId = headNum.toString().padStart(4, '0');

                const head = this.physics.add.sprite(
                    this.cannon.x,
                    this.cannon.y - 50,
                    `head_${headId}`
                );

                // Add to group immediately
                this.heads.add(head);

                // Configure the sprite
                head.setDisplaySize(this.HEAD_SIZE, this.HEAD_SIZE);

                // Set physics body
                head.body.setSize(18, 18);
                head.body.setOffset(16, 4);

                // Enable bouncing for billiard physics
                head.body.setBounce(1, 1); // Perfect elastic collision
                head.body.setDrag(0); // No drag

                // Calculate velocity
                const velocityX = Math.cos(this.cannonAngle) * this.HEAD_SPEED;
                const velocityY = Math.sin(this.cannonAngle) * this.HEAD_SPEED;

                // Set velocity
                head.body.velocity.set(velocityX, velocityY);
            }

            createBobAnimation(hedle) {
                const currentScaleX = hedle.scaleX;
                const currentScaleY = hedle.scaleY;

                hedle.bobTween = this.tweens.add({
                    targets: hedle,
                    scaleY: currentScaleY * 1.02,
                    scaleX: currentScaleX * 0.98,
                    duration: 500,
                    yoyo: true,
                    repeat: -1,
                    ease: 'Sine.easeInOut'
                });
            }

            startMovementCycle(hedle) {
                if (hedle.isDying || !hedle.active) return;

                // Start moving phase
                hedle.isMoving = true;
                hedle.walkSpriteIndex = 0;

                // Pick new random direction
                hedle.direction = Phaser.Math.FloatBetween(Math.PI * 0.25, Math.PI * 0.75);

                // Set velocity
                const velX = Math.cos(hedle.direction) * this.HEDLE_SPEED;
                const velY = Math.sin(hedle.direction) * this.HEDLE_SPEED;
                hedle.body.setVelocity(velX, velY);

                // Animate walking sprites
                hedle.walkTimer = this.time.addEvent({
                    delay: this.HEDLE_WALK_SPRITE_INTERVAL,
                    callback: () => {
                        if (!hedle.isDying && hedle.active && hedle.isMoving) {
                            hedle.walkSpriteIndex = (hedle.walkSpriteIndex + 1) % 2;
                            const side = hedle.walkSpriteIndex === 0 ? 'L_sd' : 'R_sd';
                            hedle.setTexture(`body_${hedle.hedleId}_${side}`);
                        }
                    },
                    loop: true
                });

                // After move time, start waiting phase
                hedle.moveCycleTimer = this.time.delayedCall(this.HEDLE_MOVE_TIME, () => {
                    if (hedle.isDying || !hedle.active) return;

                    // Stop moving
                    hedle.isMoving = false;
                    hedle.body.setVelocity(0, 0);

                    // Clean up walk timer
                    if (hedle.walkTimer) hedle.walkTimer.destroy();

                    // Show front sprite
                    hedle.setTexture(`body_${hedle.hedleId}_ft`);

                    // After wait time, restart cycle
                    hedle.waitCycleTimer = this.time.delayedCall(this.HEDLE_WAIT_TIME, () => {
                        this.startMovementCycle(hedle);
                    });
                });
            }

            canHitHedle(head, hedle) {
                // Only hit if head is moving fast enough
                const speed = Math.sqrt(head.body.velocity.x ** 2 + head.body.velocity.y ** 2);
                return speed >= this.MIN_HEAD_DAMAGE_SPEED && !hedle.isDying;
            }

            hitHedle(head, hedle) {
                if (hedle.isDying) return;

                hedle.isDying = true;

                // Clean up timers
                if (hedle.walkTimer) hedle.walkTimer.destroy();
                if (hedle.bobTween) hedle.bobTween.destroy();
                if (hedle.moveCycleTimer) hedle.moveCycleTimer.destroy();
                if (hedle.waitCycleTimer) hedle.waitCycleTimer.destroy();

                // Death animation - rotate around feet
                hedle.body.setVelocity(0, 0);
                hedle.body.enable = false; // Disable physics to prevent further collisions

                // Store current position before changing origin
                const currentY = hedle.y;

                // Change origin to bottom center for rotation
                hedle.setOrigin(0.5, 1);

                // Adjust position to compensate for origin change
                // When origin changes from center to bottom, we need to move sprite down
                hedle.y = currentY + (hedle.displayHeight / 2);

                // Randomly fall left or right
                const fallDirection = Phaser.Math.Between(0, 1) === 0 ? -1 : 1;

                this.tweens.add({
                    targets: hedle,
                    rotation: (Math.PI / 2) * fallDirection,
                    alpha: 0,
                    duration: 1000,
                    onComplete: () => hedle.destroy()
                });

                // Update score
                this.score++;
                this.scoreText.setText(`Score: ${this.score}`);

                // Bounce head - reduce speed by half
                const currentSpeed = Math.sqrt(head.body.velocity.x ** 2 + head.body.velocity.y ** 2);
                const newSpeed = currentSpeed * 0.5;
                const bounceAngle = Phaser.Math.FloatBetween(0, Math.PI * 2);
                const newVelX = Math.cos(bounceAngle) * newSpeed;
                const newVelY = Math.sin(bounceAngle) * newSpeed;
                head.body.setVelocity(newVelX, newVelY);
            }

            headCollision(head1, head2) {
                // Billiard-style collision already handled by Phaser's physics
                // No damping - keep full velocity
            }

            checkGameOver() {
                this.hedles.children.entries.forEach(hedle => {
                    if (!hedle.isDying && hedle.y > this.gameHeight - 150) {
                        this.endGame();
                    }
                });
            }

            endGame() {
                if (this.gameOver) return; // Prevent multiple calls

                this.gameOver = true;
                this.stopFiring(); // Stop any continuous firing

                // Clean up all timers
                if (this.eggSpawnTimer) this.eggSpawnTimer.destroy();
                if (this.chargeTimer) this.chargeTimer.destroy();

                // Stop all hedles
                this.hedles.children.entries.forEach(hedle => {
                    if (hedle.body) hedle.body.setVelocity(0, 0);
                    if (hedle.walkTimer) hedle.walkTimer.destroy();
                    if (hedle.bobTween) hedle.bobTween.destroy();
                    if (hedle.moveCycleTimer) hedle.moveCycleTimer.destroy();
                    if (hedle.waitCycleTimer) hedle.waitCycleTimer.destroy();
                });

                // Clean up all eggs
                this.eggs.forEach(egg => {
                    // Cancel all growth timers
                    for (let i = 1; i <= 4; i++) {
                        if (egg[`growthTimer${i}`]) egg[`growthTimer${i}`].destroy();
                    }
                    if (egg.hatchTimer) egg.hatchTimer.destroy();
                    egg.destroy();
                });
                this.eggs = [];

                this.add.text(this.gameWidth / 2, this.gameHeight / 2, 'GAME OVER', {
                    fontSize: '96px',
                    fill: '#ff0000'
                }).setOrigin(0.5);

                this.add.text(this.gameWidth / 2, this.gameHeight / 2 + 100, `Final Score: ${this.score}`, {
                    fontSize: '48px',
                    fill: '#ffffff'
                }).setOrigin(0.5);

                // Add play again button
                const playAgainButton = this.add.text(this.gameWidth / 2, this.gameHeight / 2 + 200, 'PLAY AGAIN', {
                    fontSize: '48px',
                    fill: '#00ff00',
                    backgroundColor: '#000000',
                    padding: { x: 20, y: 10 }
                }).setOrigin(0.5);

                playAgainButton.setInteractive();
                playAgainButton.on('pointerover', () => {
                    playAgainButton.setScale(1.1);
                    playAgainButton.setFill('#ffffff');
                });
                playAgainButton.on('pointerout', () => {
                    playAgainButton.setScale(1);
                    playAgainButton.setFill('#00ff00');
                });
                playAgainButton.on('pointerdown', () => {
                    this.scene.restart();
                });
            }

            update(time, delta) {
                if (this.gameOver) return;

                // Update cooldown
                if (this.cannonOnCooldown) {
                    const elapsed = this.time.now - this.cannonCooldownStart;
                    if (elapsed >= this.CANNON_COOLDOWN_TIME) {
                        this.cannonOnCooldown = false;
                        // Try to fire again if still holding input
                        if (this.isFiring) {
                            this.attemptToFire();
                        }
                    }
                }

                // Cannon charging animation
                if (this.cannonCharging) {
                    const chargeProgress = (this.time.now - this.cannonChargeStart) / this.CANNON_CHARGE_TIME;
                    const shakeIntensity = Math.min(chargeProgress * 10, 10);

                    this.cannon.x = this.gameWidth / 2 + (Math.random() - 0.5) * shakeIntensity;
                    this.cannon.y = this.gameHeight - 100 + (Math.random() - 0.5) * shakeIntensity;
                    this.cannon.setTint(0xff4444);
                } else {
                    this.cannon.x = this.gameWidth / 2;
                    this.cannon.y = this.gameHeight - 100;
                    this.cannon.setTint(0xffffff);
                }

                // Keep hedles within bounds
                this.hedles.children.entries.forEach(hedle => {
                    if (!hedle.isDying && hedle.isMoving) {
                        // Clamp position to screen bounds
                        if (hedle.x < 40) {
                            hedle.x = 40;
                            hedle.body.setVelocityX(Math.abs(hedle.body.velocity.x));
                        } else if (hedle.x > this.gameWidth - 40) {
                            hedle.x = this.gameWidth - 40;
                            hedle.body.setVelocityX(-Math.abs(hedle.body.velocity.x));
                        }

                        if (hedle.y < 40) {
                            hedle.y = 40;
                            hedle.body.setVelocityY(Math.abs(hedle.body.velocity.y));
                        }
                    }
                });

                // Clean up off-screen heads only
                this.heads.children.entries.forEach(head => {
                    if (head.x < -200 || head.x > this.gameWidth + 200 ||
                        head.y < -200 || head.y > this.gameHeight + 200) {
                        head.destroy();
                    }
                });

                this.checkGameOver();
            }
        }

        const config = {
            type: Phaser.AUTO,
            width: 900,
            height: 1600,
            parent: 'game-container',
            physics: {
                default: 'arcade',
                arcade: {
                    gravity: { y: 0 },
                    debug: true
                }
            },
            scene: HEDLES,
            scale: {
                mode: Phaser.Scale.FIT,
                autoCenter: Phaser.Scale.CENTER_BOTH
            }
        };

        const game = new Phaser.Game(config);
    </script>
</body>

</html>