<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>HEDLES</title>

    <!-- Favicon -->
    <link rel="icon" type="image/png" href="assets/bat_icon.png">

    <!-- Google Fonts - Press Start 2P with fallback to local -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">

    <script src="https://cdnjs.cloudflare.com/ajax/libs/phaser/3.70.0/phaser.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100vh;
            background: #000000;
            font-family: monospace;
            touch-action: none;
            overflow: hidden;
            position: fixed;
            top: 0;
            left: 0;
        }

        html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/@farcade/game-sdk@latest/dist/index.min.js"></script>
</head>

<body>
    <div id="game-container"></div>

    <script>
        const BASE_URL = 'https://hedles.loiyaa.com/';

        // ======================================
        // MINIMAL SHARED UTILITIES (Only genuinely duplicated code)
        // ======================================

        class SharedUtils {
            // Shared button press animation (was identical across scenes)
            static buttonPress(scene, button, pressedTexture, targetScene) {
                if (scene.cache.audio.exists('tap_button')) {
                    scene.sound.play('tap_button');
                }

                const originalTexture = button.texture.key;
                button.setTexture(pressedTexture);

                scene.time.delayedCall(150, () => {
                    button.setTexture(originalTexture);
                    scene.time.delayedCall(50, () => {
                        if (typeof targetScene === 'function') {
                            targetScene();
                        } else {
                            scene.scene.start(targetScene);
                        }
                    });
                });
            }

            // Shared layout calculations - updated for 2:3 aspect ratio
            static getBookLayout() {
                const gameWidth = 900;
                const gameHeight = 1350;
                const centerX = gameWidth / 2;
                const bookScale = gameWidth / 1024; // 0.878
                const scaledBookHeight = 1220 * bookScale; // 1071px
                const bookY = gameHeight * 0.42; // Middle ground between center (0.5) and too high (0.3)
                const buttonSpacing = 128; // Fixed spacing between book and buttons
                const bottomButtonY = bookY + (scaledBookHeight / 2) + buttonSpacing; // Position relative to book

                return {
                    gameWidth,
                    gameHeight,
                    centerX,
                    bookScale,
                    scaledBookHeight,
                    bookY,
                    bottomButtonY,
                    storyButtonX: gameWidth * 0.25,
                    playButtonX: gameWidth * 0.75
                };
            }

            // Shared text wrapping (duplicated between Story and Game Over)
            static wrapText(text, fontFamily, fontSize, maxWidth, scene) {
                const words = text.split(' ');
                const lines = [];
                let currentLine = '';

                const measureText = scene.add.text(0, 0, '', {
                    fontFamily: fontFamily,
                    fontSize: fontSize
                });

                for (let i = 0; i < words.length; i++) {
                    const word = words[i];
                    const testLine = currentLine ? `${currentLine} ${word}` : word;

                    measureText.setText(testLine);
                    const lineWidth = measureText.width;

                    if (lineWidth <= maxWidth || currentLine === '') {
                        currentLine = testLine;
                    } else {
                        lines.push(currentLine);
                        currentLine = word;
                    }
                }

                if (currentLine) {
                    lines.push(currentLine);
                }

                measureText.destroy();
                return lines.join('\n');
            }
        }

        // Start Screen Scene
        class StartScreen extends Phaser.Scene {
            constructor() {
                super({ key: 'StartScreen' });
            }

            preload() {
                // Load start screen assets
                this.load.image('cover_hedles', BASE_URL + 'assets/cover_hedles.jpg');
                this.load.image('click_story', BASE_URL + 'assets/click_story.png');
                this.load.image('click_story2', BASE_URL + 'assets/click_story2.png');
                this.load.image('click_play', BASE_URL + 'assets/click_play.png');
                this.load.image('click_play2', BASE_URL + 'assets/click_play2.png');
                this.load.audio('tap_button', BASE_URL + 'assets/tap_button.mp3');
            }

            create() {
                this.cameras.main.setBackgroundColor(0x000000);

                const layout = SharedUtils.getBookLayout();

                // Add cover image (scaled to fit canvas width)
                this.cover = this.add.image(layout.centerX, layout.bookY, 'cover_hedles');
                this.cover.setDisplaySize(layout.gameWidth, layout.scaledBookHeight);

                // Story button (bottom left)
                this.storyButton = this.add.image(layout.storyButtonX, layout.bottomButtonY, 'click_story');
                this.storyButton.setDisplaySize(384, 192);
                this.storyButton.setInteractive();
                this.storyButton.on('pointerover', () => {
                    this.storyButton.setTint(0xcccccc);
                });
                this.storyButton.on('pointerout', () => {
                    this.storyButton.setTint(0xffffff);
                });
                this.storyButton.on('pointerdown', () => {
                    SharedUtils.buttonPress(this, this.storyButton, 'click_story2', 'StoryScreen');
                });

                // Play button (bottom right)
                this.playButton = this.add.image(layout.playButtonX, layout.bottomButtonY, 'click_play');
                this.playButton.setDisplaySize(384, 192);
                this.playButton.setInteractive();
                this.playButton.on('pointerover', () => {
                    this.playButton.setTint(0xcccccc);
                });
                this.playButton.on('pointerout', () => {
                    this.playButton.setTint(0xffffff);
                });
                this.playButton.on('pointerdown', () => {
                    SharedUtils.buttonPress(this, this.playButton, 'click_play2', 'GameScreen');
                });

                // Keyboard support
                this.enterKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.ENTER);
                this.enterKey.on('down', () => {
                    SharedUtils.buttonPress(this, this.playButton, 'click_play2', 'GameScreen');
                });

                // Farcade SDK: Signal that the game is fully loaded and ready to play
                if (window.FarcadeSDK) {
                    window.FarcadeSDK.singlePlayer.actions.ready();
                    console.log('Farcade SDK: Game ready signal sent.');
                }
            }
        }

        // Story Screen Scene
        class StoryScreen extends Phaser.Scene {
            constructor() {
                super({ key: 'StoryScreen' });
                this.gameWidth = 900;
                this.gameHeight = 1350; // Changed from 1600

                // Story text (themed around the game)
                this.storyLines = [
                    "Behold, the realm of Forgotten Runes. A world filled with magic and wonders.",
                    "One mystery lies above all. Shrouded in a tower whose name was lost to time.",
                    "Nobody knows what goes on in the Secret Tower.",
                    "Nobody, except the Apprentice.",
                    "Every full moon, a new Apprentice is chosen. They set out for the tower. They're never to be seen again.",
                    "Today, you are the chosen Apprentice.",
                    "The doors of the Secret Tower open in front of you.",
                    "As you step inside, runes float in front of your eyes. They spell the truth of this place.",
                    "Wizards are not born. They are made.",
                    "All begins with the Donkeyhorse.",
                    "This magical beast roams the tower halls, laying eggs as it does.",
                    "The eggs hatch into bodies, without heads. Without souls. Mindless creatures, called Hedles.",
                    "As the Apprentice, your role is to attach heads to the Hedles.",
                    "Thus, a Wizard is born.",
                    "The Hedles grow fast. To keep up with them, you must use the Headcannon.",
                    "Aim true, Apprentice. The future of all wizardy relies on you."
                ];

                this.currentLineIndex = 0;
                this.isTyping = false;
                this.canAdvance = false;
                this.typewriterSpeed = 50;
                this.typewriterSounds = [];
                this.fontLoaded = false;
            }

            preload() {
                // Load story assets
                this.load.image('cover_secret', BASE_URL + 'assets/cover_secret.jpg');
                this.load.image('text_background', BASE_URL + 'assets/text_background.png');
                this.load.image('click_story', BASE_URL + 'assets/click_story.png');
                this.load.image('click_story2', BASE_URL + 'assets/click_story2.png');
                this.load.image('click_play', BASE_URL + 'assets/click_play.png');
                this.load.image('click_play2', BASE_URL + 'assets/click_play2.png');
                this.load.audio('tap_button', BASE_URL + 'assets/tap_button.mp3');

                // Load typewriter sounds
                this.load.audio('type_blip1', BASE_URL + 'assets/type_blip1.mp3');
                this.load.audio('type_blip2', BASE_URL + 'assets/type_blip2.mp3');
                this.load.audio('type_blip3', BASE_URL + 'assets/type_blip3.mp3');

                // KEEP the sophisticated font loading system - it's necessary!
                this.load.addListener('complete', () => {
                    console.log('Assets loaded, now waiting for Google Fonts...');

                    const forceLoadFont = () => {
                        const testElement = document.createElement('div');
                        testElement.style.fontFamily = '"Press Start 2P", monospace';
                        testElement.style.fontSize = '24px';
                        testElement.style.position = 'absolute';
                        testElement.style.visibility = 'hidden';
                        testElement.style.left = '-9999px';
                        testElement.textContent = 'Test font loading';
                        document.body.appendChild(testElement);

                        document.fonts.ready.then(() => {
                            console.log('Fonts ready, forcing render...');

                            setTimeout(() => {
                                const fontLoaded = document.fonts.check('24px "Press Start 2P"');
                                console.log('Press Start 2P available:', fontLoaded);

                                this.fontLoaded = fontLoaded;
                                document.body.removeChild(testElement);
                                this.createStoryElements();

                            }, 50);

                        }).catch((error) => {
                            console.error('Font loading failed:', error);
                            document.body.removeChild(testElement);
                            this.fontLoaded = false;
                            this.createStoryElements();
                        });
                    };

                    forceLoadFont();
                });

                // Error handlers
                this.load.on('loaderror', (file) => {
                    console.warn('Missing story asset:', file.key);
                    const graphics = this.make.graphics({ x: 0, y: 0, add: false });

                    if (file.key === 'cover_secret') {
                        graphics.fillStyle(0x1a1a2e, 1);
                        graphics.fillRect(0, 0, 1024, 1220);
                        graphics.fillStyle(0x666666, 1);
                        graphics.fillRect(400, 600, 224, 50);
                        graphics.generateTexture('cover_secret', 1024, 1220);
                    } else if (file.key === 'text_background') {
                        graphics.fillStyle(0x2c1810, 1);
                        graphics.fillRect(0, 0, 1024, 256);
                        graphics.lineStyle(4, 0x8b4513);
                        graphics.strokeRect(8, 8, 1008, 240);
                        graphics.generateTexture('text_background', 1024, 256);
                    } else if (file.key.startsWith('click_story') || file.key.startsWith('click_play')) {
                        const isGolden = file.key.includes('2');
                        graphics.fillStyle(0x444444, 1);
                        graphics.fillRect(0, 0, 512, 256);
                        graphics.fillStyle(isGolden ? 0xFFD700 : 0xffffff, 1);
                        graphics.fillRect(20, 50, 472, 156);
                        graphics.generateTexture(file.key, 512, 256);
                    }

                    graphics.destroy();
                });
            }

            create() {
                this.cameras.main.setBackgroundColor(0x000000);
                // Wait for font loading to complete before creating elements
            }

            createStoryElements() {
                const layout = SharedUtils.getBookLayout();

                // Add secret cover image (positioned higher up)
                this.cover = this.add.image(layout.centerX, layout.bookY, 'cover_secret');
                this.cover.setDisplaySize(layout.gameWidth, layout.scaledBookHeight);

                // Story button (bottom left) - now properly positioned relative to book
                this.storyButton = this.add.image(layout.storyButtonX, layout.bottomButtonY, 'click_story');
                this.storyButton.setDisplaySize(384, 192);
                this.storyButton.setInteractive();
                this.storyButton.on('pointerover', () => {
                    this.storyButton.setTint(0xcccccc);
                });
                this.storyButton.on('pointerout', () => {
                    this.storyButton.setTint(0xffffff);
                });
                this.storyButton.on('pointerdown', () => {
                    SharedUtils.buttonPress(this, this.storyButton, 'click_story2', 'StoryScreen');
                });

                // Play button (bottom right) - now properly positioned relative to book
                this.playButton = this.add.image(layout.playButtonX, layout.bottomButtonY, 'click_play');
                this.playButton.setDisplaySize(384, 192);
                this.playButton.setInteractive();
                this.playButton.on('pointerover', () => {
                    this.playButton.setTint(0xcccccc);
                });
                this.playButton.on('pointerout', () => {
                    this.playButton.setTint(0xffffff);
                });
                this.playButton.on('pointerdown', () => {
                    SharedUtils.buttonPress(this, this.playButton, 'click_play2', 'GameScreen');
                });

                // Add text background at the bottom of the book - repositioned
                const textBgScale = layout.bookScale;
                const textBgWidth = 1024 * textBgScale;
                const textBgHeight = 256 * textBgScale;
                const textBgY = layout.bookY + (layout.scaledBookHeight / 2) - (textBgHeight / 2) - 20; // Bottom of book

                this.textBackground = this.add.image(layout.centerX, textBgY, 'text_background');
                this.textBackground.setDisplaySize(textBgWidth, textBgHeight);

                // Create text object for story - positioned within the repositioned background
                const textMarginX = textBgWidth * 0.08;
                const textMarginY = textBgHeight * 0.22;
                this.textWrapWidth = textBgWidth - (textMarginX * 2);

                const fontFamily = '"Press Start 2P", "Press Start 2P Local", monospace';
                const fontSize = this.fontLoaded ? '24px' : '28px';

                console.log('Creating text with font stack:', fontFamily, 'size:', fontSize);

                this.storyText = this.add.text(
                    layout.centerX - (textBgWidth / 2) + textMarginX,
                    textBgY - (textBgHeight / 2) + textMarginY,
                    '',
                    {
                        fontFamily: fontFamily,
                        fontSize: fontSize,
                        fill: '#ffffff',
                        align: 'left',
                        wordWrap: { width: this.textWrapWidth, useAdvancedWrap: true },
                        lineSpacing: 8
                    }
                );
                this.storyText.setOrigin(0, 0);

                // Add continue prompt - positioned below the repositioned dialog box
                this.continuePrompt = this.add.text(layout.centerX, textBgY + (textBgHeight / 2) + 40, 'Press SPACE or CLICK to continue...', {
                    fontFamily: '"Press Start 2P", "Press Start 2P Local", monospace',
                    fontSize: this.fontLoaded ? '18px' : '20px',
                    fill: '#888888',
                    align: 'center'
                });
                this.continuePrompt.setOrigin(0.5);
                this.continuePrompt.setVisible(false);

                // Blinking effect for continue prompt
                this.tweens.add({
                    targets: this.continuePrompt,
                    alpha: 0.3,

                    duration: 800,
                    yoyo: true,
                    repeat: -1,
                    ease: 'Sine.easeInOut'
                });

                // Collect available typewriter sounds
                this.typewriterSounds = [];
                for (let i = 1; i <= 3; i++) {
                    if (this.cache.audio.exists(`type_blip${i}`)) {
                        this.typewriterSounds.push(`type_blip${i}`);
                    }
                }

                // Input handling
                this.input.on('pointerdown', () => {
                    this.handleAdvance();
                });

                this.spaceKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);
                this.spaceKey.on('down', () => {
                    this.handleAdvance();
                });

                this.escapeKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.ESC);
                this.escapeKey.on('down', () => {
                    this.scene.start('StartScreen');
                });

                // Start the first line
                this.showNextLine();
            }
            handleAdvance() {
                if (this.isTyping) {
                    this.completeCurrentLine();
                } else if (this.canAdvance) {
                    this.currentLineIndex++;
                    if (this.currentLineIndex >= this.storyLines.length) {
                        SharedUtils.buttonPress(this, this.playButton, 'click_play2', 'GameScreen');
                    } else {
                        this.showNextLine();
                    }
                }
            }

            showNextLine() {
                if (this.currentLineIndex >= this.storyLines.length) return;

                this.isTyping = true;
                this.canAdvance = false;
                this.continuePrompt.setVisible(false);

                const fullText = this.storyLines[this.currentLineIndex];

                // Use shared text wrapping utility
                const wrappedText = SharedUtils.wrapText(
                    fullText,
                    this.storyText.style.fontFamily,
                    this.storyText.style.fontSize,
                    this.textWrapWidth,
                    this
                );

                this.currentWrappedText = wrappedText;
                this.storyText.setWordWrapWidth(0);

                // Now type the pre-wrapped text character by character
                let currentText = '';
                let charIndex = 0;

                this.storyText.setText('');

                const typeNextChar = () => {
                    if (charIndex < wrappedText.length && this.isTyping) {
                        currentText += wrappedText[charIndex];
                        this.storyText.setText(currentText);

                        if (wrappedText[charIndex] !== ' ' && wrappedText[charIndex] !== '\n' && this.typewriterSounds.length > 0) {
                            const randomSound = Phaser.Utils.Array.GetRandom(this.typewriterSounds);
                            this.sound.play(randomSound, { volume: 0.3 });
                        }

                        charIndex++;
                        this.time.delayedCall(this.typewriterSpeed, typeNextChar);
                    } else {
                        this.completeCurrentLine();
                    }
                };

                typeNextChar();
            }

            completeCurrentLine() {
                this.isTyping = false;
                this.canAdvance = true;
                this.storyText.setText(this.currentWrappedText);
                this.continuePrompt.setVisible(true);
            }
        }

        // Game Screen Scene - KEEP ALL FUNCTIONALITY INTACT!
        class GameScreen extends Phaser.Scene {
            constructor() {
                super({ key: 'GameScreen' });

                // Game configuration - Updated for 2:3 aspect ratio
                this.CANNON_SIZE = 96;
                this.CANNON_CHARGE_TIME = 500;
                this.CANNON_COOLDOWN_TIME = 1000;
                this.HEAD_SIZE = 128;
                this.HEDLE_SIZE = 160;
                this.EGG_SIZE = 80;
                this.HEAD_SPEED = 800;
                this.HEDLE_SPEED = 75;
                this.HEDLE_MOVE_TIME = 2000;
                this.HEDLE_WAIT_TIME = 1000;
                this.HEDLE_WALK_SPRITE_INTERVAL = 400;
                this.MINIMUM_SPAWN_DELAY = 1000;
                this.EGG_GROWTH_TIME = 4000;
                this.MIN_HEAD_DAMAGE_SPEED = 50;
                this.BAT_SPEED = 200;
                this.SPELL_SLOT_SIZE = 120;
                this.FIRE_EXPLOSION_RADIUS = 250;
                this.WATER_LINE_LENGTH = 3200;
                this.MULTI_SHOT_COUNT = 8;
                this.MULTI_SHOT_DELAY = 250;

                // Horse configuration
                this.HORSE_SIZE = 120;
                this.HORSE_SPEED = 150;
                this.HORSE_WALK_FRAME_DURATION = 200;
                this.HORSE_LAY_FRAME_DURATION = 200;

                // Sprite counts
                this.HEAD_COUNT = 119;
                this.HEDLE_COUNT = 84;

                // Game dimensions - Updated for 2:3 aspect ratio
                this.gameWidth = 900;
                this.gameHeight = 1350; // Changed from 1600
            }

            init() {
                // Reset all game state on init (for proper restart)
                this.score = 0;
                this.gameOver = false;
                this.cannonAngle = -Math.PI / 2;
                this.cannonCharging = false;
                this.cannonOnCooldown = false;
                this.cannonChargeStart = 0;
                this.cannonCooldownStart = 0;
                this.lastPointerPosition = { x: 450, y: 400 };
                this.currentSpawnDelay = 4000;
                this.spawnSpeedMultiplier = 0.96;
                this.currentBatDelay = 4000;
                this.batDelayIncrement = 0;
                this.spellSlots = [null, null, null, null];
                this.selectedSpell = null;
                this.activeWaterLines = [];
                this.isMultiShotting = false;
                this.isFiring = false;
                this.shotQueued = false;
                this.uiClickThisFrame = false;
                this.scoreDigits = [];
                this.DIGIT_SIZE = 96;
                this.gameOverFadeOverlay = null;
                this.currentFadeOpacity = 0;
                this.targetFadeOpacity = 0;
                this.fadeTransitionSpeed = 1.0;
                this.fadeUpdateCounter = 0;
                this.activeHedleMessages = 0;
                this.floatingTexts = [];
                this.MAX_HEDLE_MESSAGES = 8;

                // Message arrays
                this.batMessages = [
                    "Don't shoot me!",
                    "I'm friendly!",
                    "Tap my book!",
                    "Spells here!",
                    "Magic delivery!",
                    "Hedles feel no pain",
                    "Tap the tome",
                    "Keep your ears open"
                ];

                this.hedleMessages = [
                    "orange turn",
                    "wen tge",
                    "yellow peasant",
                    "ten pair",
                    "twelve donate",
                    "gm",
                    "cyan play",
                    "three stars",
                    "how to get role",
                    "hey sir",
                    "purple mystery",
                    "pink capable",
                    "brans",
                    "umm",
                    "hug me",
                    "blue crew",
                    "beige hero",
                    "eleven mutual",
                    "green pudding",
                    "nine list"
                ];

                // Game over state
                this.gameOverMessage = null;
                this.gameOverPlayButton = null;
                this.fontLoaded = false;
                this.typewriterSounds = [];
                this.gameOverMessages = [
                    "The darkness engulfs you...",
                    "As you lose consciousness, odd runes twirl around your head: KA JI SU LI",
                    "Bats don't need HED, they just need the Apprentice's love. Poke them gently, and they'll thank you in silence.",
                    "WEN TGE",
                    "Some say they hear screams coming from the secret tower , but somehow seem strangely muffled, as if they are coming from closed mouths..."
                ];

                // Horse state
                this.horse = null;
                this.horseWalkFrame = 0;
                this.horseIsLaying = false;
                this.horseAngle = 0;
                this.horseVelocityX = 0;
                this.horseVelocityY = 0;
                this.pendingEggSpawn = false;

                // Replace single horse variables with multi-horse system
                this.horses = []; // Array to hold all horses
                this.horseSpawnData = []; // Array to track each horse's spawn timing
                this.nextHorseId = 0; // Counter for horse IDs
                this.NEW_HORSE_DELAY = 30000;

                // Loading state
                this.loadingText = null;
                this.loadingTween = null;

                // Show loading message immediately when scene starts
                this.showLoadingMessage();
            }

            preload() {
                // Load ALL game assets exactly as before
                this.load.image('cannon', BASE_URL + 'assets/cannon.png');
                this.load.audio('cannon_shot', BASE_URL + 'assets/cannon_shot.mp3');
                this.load.audio('hedles_music', BASE_URL + 'assets/HEDLES.mp3');
                this.load.image('click_play', BASE_URL + 'assets/click_play.png');
                this.load.image('click_play2', BASE_URL + 'assets/click_play2.png');
                this.load.audio('tap_button', BASE_URL + 'assets/tap_button.mp3');
                this.load.audio('type_blip1', BASE_URL + 'assets/type_blip1.mp3');
                this.load.audio('type_blip2', BASE_URL + 'assets/type_blip2.mp3');
                this.load.audio('type_blip3', BASE_URL + 'assets/type_blip3.mp3');
                this.load.image('background', BASE_URL + 'assets/background.png');
                this.load.audio('oww_1', BASE_URL + 'assets/oww_1.mp3');
                this.load.audio('oww_2', BASE_URL + 'assets/oww_2.mp3');
                this.load.audio('oww_3', BASE_URL + 'assets/oww_3.mp3');
                this.load.audio('oww_4', BASE_URL + 'assets/oww_4.mp3');
                this.load.audio('pickup_spell', BASE_URL + 'assets/pickup_spell.mp3');
                this.load.audio('ball_bounce', BASE_URL + 'assets/ball_bounce.mp3');
                this.load.image('egg', BASE_URL + 'assets/item_egg.png');

                // Load bat animation sprites
                this.load.image('bat_1', BASE_URL + 'assets/bat_1.png');
                this.load.image('bat_2', BASE_URL + 'assets/bat_2.png');
                this.load.image('bat_3', BASE_URL + 'assets/bat_3.png');
                this.load.image('bat_4', BASE_URL + 'assets/bat_4.png');

                // Load book sprites
                this.load.image('tome_fire', BASE_URL + 'assets/tome_fire.png');
                this.load.image('tome_water', BASE_URL + 'assets/tome_water.png');
                this.load.image('tome_storm', BASE_URL + 'assets/tome_storm.png');
                this.load.image('tome_multi', BASE_URL + 'assets/tome_multi.png');

                // Load spell interface icons
                this.load.image('icon_blank', BASE_URL + 'assets/icon_blank.png');
                this.load.image('icon_fire', BASE_URL + 'assets/icon_fire.png');
                this.load.image('icon_water', BASE_URL + 'assets/icon_water.png');
                this.load.image('icon_storm', BASE_URL + 'assets/icon_storm.png');
                this.load.image('icon_multi', BASE_URL + 'assets/icon_multi.png');

                // Load spell effect sprites
                this.load.image('spell_fire', BASE_URL + 'assets/spell_fire.png');
                this.load.image('spell_water', BASE_URL + 'assets/spell_water.png');
                this.load.image('spell_storm', BASE_URL + 'assets/spell_storm.png');
                this.load.image('spell_multi', BASE_URL + 'assets/spell_multi.png');

                // Load digit sprites for score
                for (let i = 0; i <= 9; i++) {
                    this.load.image(`digit_${i}`, BASE_URL + `assets/digit_${i}.png`);
                }

                // Load horse sprites
                for (let i = 1; i <= 8; i++) {
                    this.load.image(`horse_walk_${i}`, BASE_URL + `assets/horse_walk_${i}.png`);
                }

                for (let i = 1; i <= 3; i++) {
                    this.load.image(`horse_egg_${i}`, BASE_URL + `assets/horse_egg_${i}.png`);
                }

                // KEEP the sophisticated font loading system
                this.load.addListener('complete', () => {
                    console.log('Game assets loaded, font should be available from Google Fonts...');
                    this.fontLoaded = true;
                });

                this.load.addListener('complete', () => {
                    this.typewriterSounds = [];
                    for (let i = 1; i <= 3; i++) {
                        if (this.cache.audio.exists(`type_blip${i}`)) {
                            this.typewriterSounds.push(`type_blip${i}`);
                        }
                    }
                });

                // Load head sprites
                for (let i = 1; i <= this.HEAD_COUNT; i++) {
                    const num = i.toString().padStart(4, '0');
                    this.load.image(`head_${num}`, BASE_URL + `assets/head_${num}_ft.png`);
                }

                // Load hedle sprites
                for (let i = 1; i <= this.HEDLE_COUNT; i++) {
                    const num = i.toString().padStart(4, '0');
                    this.load.image(`body_${num}_ft`, BASE_URL + `assets/body_${num}_ft.png`);
                    this.load.image(`body_${num}_bk`, BASE_URL + `assets/body_${num}_bk.png`);
                    this.load.image(`body_${num}_L_sd`, BASE_URL + `assets/body_${num}_L_sd.png`);
                    this.load.image(`body_${num}_R_sd`, BASE_URL + `assets/body_${num}_R_sd.png`);
                }
            }

            create() {
                // Create golden dot texture for particles
                const graphics = this.make.graphics({ x: 0, y: 0, add: false });
                graphics.fillStyle(0xFFD700, 1);
                graphics.fillCircle(4, 4, 4);
                graphics.generateTexture('golden_dot', 8, 8);
                graphics.destroy();

                // red hedle particles
                const redGraphics = this.make.graphics({ x: 0, y: 0, add: false });
                redGraphics.fillStyle(0xff0000, 1);
                redGraphics.fillCircle(4, 4, 4);
                redGraphics.generateTexture('red_dot', 8, 8);
                redGraphics.destroy();

                // Set background with tiled texture
                this.cameras.main.setBackgroundColor(0x2c3e50);

                // Tile the background texture - adjusted for new height
                const bgWidth = 900;
                const bgHeight = 1024;
                const tilesX = Math.ceil(this.gameWidth / bgWidth);
                const tilesY = Math.ceil(this.gameHeight / bgHeight);

                for (let x = 0; x < tilesX; x++) {
                    for (let y = 0; y < tilesY; y++) {
                        const bg = this.add.image(x * bgWidth, y * bgHeight, 'background');
                        bg.setOrigin(0, 0);
                        bg.setDepth(-10);
                    }
                }

                // Set world bounds for physics - adjusted for new height
                this.physics.world.setBounds(0, 0, this.gameWidth, this.gameHeight);
                this.physics.world.setBoundsCollision(true, true, true, true);

                // Create physics groups
                this.hedles = this.physics.add.group();
                this.heads = this.physics.add.group();
                this.eggs = [];

                // Create cannon - adjusted position for new height
                this.cannon = this.add.image(this.gameWidth / 2, this.gameHeight - 85, 'cannon'); // Adjusted from gameHeight - 100
                this.cannon.setDisplaySize(this.CANNON_SIZE, this.CANNON_SIZE * 2);
                this.cannon.setOrigin(0.5, 0.5);
                this.cannon.setDepth(200);

                // Create horse - KEEP THE EXACT IMPLEMENTATION!
                this.createHorse();

                // Set up collision detection with condition check
                this.physics.add.overlap(this.heads, this.hedles, this.hitHedle, this.canHitHedle, this);
                this.physics.add.collider(this.heads, this.heads, this.headCollision, this.canHeadsCollide, this);

                // Create screen fade overlay for tension effect - adjusted for new height
                this.gameOverFadeOverlay = this.add.graphics();
                this.gameOverFadeOverlay.fillStyle(0x000000, 0);
                this.gameOverFadeOverlay.fillRect(0, 0, this.gameWidth, this.gameHeight);
                this.gameOverFadeOverlay.setDepth(50);

                // Input handling - KEEP EXACTLY AS IT WAS
                this.input.removeAllListeners();

                this.input.on('pointermove', (pointer) => {
                    this.lastPointerPosition = { x: pointer.x, y: pointer.y };
                    this.updateCannonAngle();
                });

                this.input.on('pointerdown', (pointer) => {
                    this.lastPointerPosition = { x: pointer.x, y: pointer.y };
                    this.updateCannonAngle();
                    if (!this.uiClickThisFrame) {
                        this.startFiring();
                    }
                });

                this.input.on('pointerup', () => {
                    this.stopFiring();
                });

                // Keyboard support
                this.spaceKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);
                this.spaceKey.on('down', () => {
                    this.startFiring();
                });
                this.spaceKey.on('up', () => {
                    this.stopFiring();
                });

                this.escapeKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.ESC);
                this.escapeKey.on('down', () => {
                    if (this.backgroundMusic && this.backgroundMusic.isPlaying) {
                        this.backgroundMusic.stop();
                    }
                    this.scene.start('StartScreen');
                });

                this.isFiring = false;

                // Initialize score display with 0
                this.updateScoreDisplay();

                // Create spell interface
                this.createSpellInterface();

                // Start spawning with first egg immediately - CRITICAL PART!
                this.triggerEggSpawnForHorse(0);
                this.scheduleNextEggForHorse(0);

                // Schedule first bat
                this.scheduleBat();

                // Start background music
                if (this.cache.audio.exists('hedles_music')) {
                    this.backgroundMusic = this.sound.add('hedles_music', {
                        loop: true,
                        volume: 0.5
                    });
                    this.backgroundMusic.play();
                }

                // Hide loading message after a short delay to ensure everything is ready
                this.time.delayedCall(100, () => {
                    this.hideLoadingMessage();
                });
            }

            createImpactSparks(x, y) {
                // Create individual spark particles manually instead of using explode()
                const numSparks = 12;

                for (let i = 0; i < numSparks; i++) {
                    // Random angle for each spark
                    const angle = (Math.PI * 2 * i) / numSparks + Phaser.Math.FloatBetween(-0.3, 0.3);
                    const speed = Phaser.Math.Between(200, 400);

                    // Create individual spark
                    const spark = this.add.image(x, y, 'golden_dot');
                    spark.setScale(1.5);
                    spark.setDepth(300);

                    // Calculate velocity
                    const velX = Math.cos(angle) * speed;
                    const velY = Math.sin(angle) * speed;

                    // Animate the spark
                    this.tweens.add({
                        targets: spark,
                        x: x + velX * 0.8, // Move outward
                        y: y + velY * 0.8 + 80, // Move outward + gravity effect
                        scaleX: 0.1,
                        scaleY: 0.1,
                        alpha: 0,
                        duration: 1000,
                        ease: 'Quad.easeOut',
                        onComplete: () => {
                            if (spark && spark.active) {
                                spark.destroy();
                            }
                        }
                    });
                }
            }

            showLoadingMessage() {
                // Set black background immediately
                this.cameras.main.setBackgroundColor(0x000000);

                // Create loading text using system font initially - adjusted position for new height
                this.loadingText = this.add.text(
                    this.gameWidth / 2,
                    this.gameHeight / 2,
                    'ENTERING THE TOWER...',
                    {
                        fontFamily: 'monospace',
                        fontSize: '32px',
                        fill: '#ffffff',
                        align: 'center'
                    }
                );
                this.loadingText.setOrigin(0.5);
                this.loadingText.setDepth(1000);
                this.loadingText.setAlpha(0);

                // Fade in and create pulsing animation
                this.tweens.add({
                    targets: this.loadingText,
                    alpha: 1,
                    duration: 500,
                    ease: 'Power2',
                    onComplete: () => {
                        this.loadingTween = this.tweens.add({
                            targets: this.loadingText,
                            alpha: 0.4,
                            duration: 1000,
                            yoyo: true,
                            repeat: -1,
                            ease: 'Sine.easeInOut'
                        });
                    }
                });

                // KEEP the sophisticated font upgrade system
                this.tryUpgradeLoadingFont();
            }

            tryUpgradeLoadingFont() {
                const fontLoaded = document.fonts.check('32px "Press Start 2P"');

                if (fontLoaded && this.loadingText && this.loadingText.active) {
                    this.loadingText.setFontFamily('"Press Start 2P", "Press Start 2P Local", monospace');
                    return;
                }

                const forceLoadFont = () => {
                    const testElement = document.createElement('div');
                    testElement.style.fontFamily = '"Press Start 2P", monospace';
                    testElement.style.fontSize = '32px';
                    testElement.style.position = 'absolute';
                    testElement.style.visibility = 'hidden';
                    testElement.style.left = '-9999px';
                    testElement.textContent = 'ENTERING THE TOWER...';
                    document.body.appendChild(testElement);

                    document.fonts.ready.then(() => {
                        setTimeout(() => {
                            const fontNowLoaded = document.fonts.check('32px "Press Start 2P"');

                            if (fontNowLoaded && this.loadingText && this.loadingText.active) {
                                this.loadingText.setFontFamily('"Press Start 2P", "Press Start 2P Local", monospace');
                            }

                            document.body.removeChild(testElement);
                        }, 50);
                    }).catch((error) => {
                        console.warn('Font loading failed for loading message:', error);
                        document.body.removeChild(testElement);
                    });
                };

                forceLoadFont();
            }

            hideLoadingMessage() {
                if (this.loadingText) {
                    if (this.loadingTween) {
                        this.loadingTween.destroy();
                    }

                    this.tweens.add({
                        targets: this.loadingText,
                        alpha: 0,
                        duration: 500,
                        ease: 'Power2',
                        onComplete: () => {
                            this.loadingText.destroy();
                            this.loadingText = null;
                        }
                    });
                }
            }

            createHorse(startFromTop = false) {
                let spawnX, spawnY;

                if (startFromTop) {
                    // New horses enter from top of screen
                    spawnX = Phaser.Math.Between(150, this.gameWidth - 150);
                    spawnY = -50; // Start above screen
                } else {
                    // First horse spawns normally
                    spawnX = Phaser.Math.Between(150, this.gameWidth - 150);
                    spawnY = Phaser.Math.Between(50, 150);
                }

                const horse = this.add.sprite(spawnX, spawnY, 'horse_walk_1');
                horse.setDisplaySize(this.HORSE_SIZE, this.HORSE_SIZE);
                horse.setDepth(100);
                horse.horseId = this.nextHorseId++;
                horse.walkFrame = 0;
                horse.isLaying = false;
                horse.angle = this.getRandomHorseDirection();
                horse.velocityX = Math.cos(horse.angle) * this.HORSE_SPEED;
                horse.velocityY = Math.sin(horse.angle) * this.HORSE_SPEED;
                horse.pendingEggSpawn = false;

                // If starting from top, make it walk down initially
                if (startFromTop) {
                    horse.velocityY = Math.abs(horse.velocityY); // Force downward movement initially
                }

                // Create spawn data for this horse
                const spawnData = {
                    horseId: horse.horseId,
                    currentSpawnDelay: 4000, // Start with base delay
                    spawnTimer: null,
                    hasReachedMaxRate: false,
                    nextHorseScheduled: false
                };

                this.horses.push(horse);
                this.horseSpawnData.push(spawnData);

                this.startHorseWalking(horse);

                // Start spawning for this horse
                this.scheduleNextEggForHorse(horse.horseId);

                console.log(`Created horse ${horse.horseId} ${startFromTop ? 'from top' : 'normally'}`);

                return horse;
            }
            getRandomHorseDirection() {
                const goingLeft = Phaser.Math.Between(0, 1) === 0;

                if (goingLeft) {
                    return Phaser.Math.FloatBetween(157.5 * Math.PI / 180, 202.5 * Math.PI / 180);
                } else {
                    return Phaser.Math.FloatBetween(-22.5 * Math.PI / 180, 22.5 * Math.PI / 180);
                }
            }

            startHorseWalking(horse) {
                horse.walkTimer = this.time.addEvent({
                    delay: this.HORSE_WALK_FRAME_DURATION,
                    callback: () => {
                        if (!horse.isLaying && horse && horse.active) {
                            horse.walkFrame = (horse.walkFrame % 8) + 1;
                            horse.setTexture(`horse_walk_${horse.walkFrame}`);
                        }
                    },
                    loop: true
                });
            }

            updateHorseMovement() {
                this.horses.forEach(horse => {
                    if (!horse || !horse.active || horse.isLaying) return;

                    horse.x += horse.velocityX * (1 / 60);
                    horse.y += horse.velocityY * (1 / 60);

                    const margin = 60;
                    let directionChanged = false;

                    if (horse.x < margin) {
                        horse.x = margin;
                        horse.velocityX = Math.abs(horse.velocityX);
                        directionChanged = true;
                    } else if (horse.x > this.gameWidth - margin) {
                        horse.x = this.gameWidth - margin;
                        horse.velocityX = -Math.abs(horse.velocityX);
                        directionChanged = true;
                    }

                    if (horse.y < 30) {
                        horse.y = 30;
                        horse.velocityY = Math.abs(horse.velocityY);
                        directionChanged = true;
                    } else if (horse.y > 200) {
                        horse.y = 200;
                        horse.velocityY = -Math.abs(horse.velocityY);
                        directionChanged = true;
                    }

                    if (directionChanged) {
                        horse.angle = Math.atan2(horse.velocityY, horse.velocityX);
                    }

                    horse.setFlipX(horse.velocityX > 0);
                });
            }

            // New method to find horse by ID:
            findHorseById(horseId) {
                return this.horses.find(horse => horse.horseId === horseId);
            }

            // New method to find spawn data by horse ID:
            findSpawnDataById(horseId) {
                return this.horseSpawnData.find(data => data.horseId === horseId);
            }


            triggerEggSpawnForHorse(horseId) {
                const horse = this.findHorseById(horseId);
                if (this.gameOver || !horse || !horse.active) return;

                horse.pendingEggSpawn = true;
                this.startHorseLayingAnimation(horse);
            }

            startHorseLayingAnimation(horse) {
                if (horse.isLaying) return;

                horse.isLaying = true;

                if (horse.walkTimer) {
                    horse.walkTimer.paused = true;
                }

                let layFrame = 1;
                const layFrames = 3;

                const layAnimation = () => {
                    if (layFrame <= layFrames && horse && horse.active) {
                        horse.setTexture(`horse_egg_${layFrame}`);

                        if (layFrame === 2 && horse.pendingEggSpawn) {
                            this.spawnEggAtHorse(horse);
                            horse.pendingEggSpawn = false;
                        }

                        layFrame++;

                        if (layFrame <= layFrames) {
                            this.time.delayedCall(this.HORSE_LAY_FRAME_DURATION, layAnimation);
                        } else {
                            this.endHorseLayingAnimation(horse);
                        }
                    }
                };

                layAnimation();
            }


            endHorseLayingAnimation(horse) {
                horse.isLaying = false;

                horse.walkFrame = 1;
                if (horse && horse.active) {
                    horse.setTexture(`horse_walk_${horse.walkFrame}`);
                }

                horse.angle = this.getRandomHorseDirection();
                horse.velocityX = Math.cos(horse.angle) * this.HORSE_SPEED;
                horse.velocityY = Math.sin(horse.angle) * this.HORSE_SPEED;

                if (horse.walkTimer) {
                    horse.walkTimer.paused = false;
                }
            }

            spawnEggAtHorse(horse) {
                if (this.gameOver || !horse || !horse.active) return;

                const horseIsFlipped = horse.flipX;
                const rearOffsetDistance = 40;

                let spawnX, spawnY;

                if (horseIsFlipped) {
                    spawnX = horse.x - rearOffsetDistance;
                } else {
                    spawnX = horse.x + rearOffsetDistance;
                }

                spawnY = horse.y + 10;

                spawnX = Phaser.Math.Clamp(spawnX, 150, this.gameWidth - 150);
                spawnY = Phaser.Math.Clamp(spawnY, 50, 200);

                const egg = this.add.sprite(spawnX, spawnY, 'egg');
                egg.setDisplaySize(this.EGG_SIZE, this.EGG_SIZE);
                egg.hedleId = Phaser.Math.Between(1, this.HEDLE_COUNT).toString().padStart(4, '0');
                egg.growthTimer = 0;

                this.eggs.push(egg);

                const growthSteps = 4;
                for (let i = 1; i <= growthSteps; i++) {
                    const timer = this.time.delayedCall(i * 1000, () => {
                        if (egg && egg.active && !this.gameOver) {
                            const newSize = this.EGG_SIZE * (1 + i * 0.25);
                            egg.setDisplaySize(newSize, newSize);

                            this.tweens.add({
                                targets: egg,
                                scaleX: egg.scaleX * 1.1,
                                scaleY: egg.scaleY * 1.1,
                                duration: 200,
                                yoyo: true,
                                ease: 'Sine.easeInOut'
                            });
                        }
                    });
                    egg[`growthTimer${i}`] = timer;
                }

                egg.hatchTimer = this.time.delayedCall(this.EGG_GROWTH_TIME, () => {
                    if (egg && egg.active && !this.gameOver) {
                        this.hatchEgg(egg);
                    }
                });
            }

            scheduleNextEggForHorse(horseId) {
                if (this.gameOver) return;

                const spawnData = this.findSpawnDataById(horseId);
                if (!spawnData) return;

                spawnData.spawnTimer = this.time.delayedCall(spawnData.currentSpawnDelay, () => {
                    this.triggerEggSpawnForHorse(horseId);

                    // Update spawn delay for this horse
                    spawnData.currentSpawnDelay *= this.spawnSpeedMultiplier;
                    spawnData.currentSpawnDelay = Math.max(this.MINIMUM_SPAWN_DELAY, spawnData.currentSpawnDelay);

                    // Check if this horse just reached max rate
                    if (!spawnData.hasReachedMaxRate && spawnData.currentSpawnDelay <= this.MINIMUM_SPAWN_DELAY) {
                        spawnData.hasReachedMaxRate = true;
                        console.log(`Horse ${horseId} reached maximum spawn rate!`);

                        // Schedule next horse after delay
                        if (!spawnData.nextHorseScheduled) {
                            spawnData.nextHorseScheduled = true;
                            this.time.delayedCall(this.NEW_HORSE_DELAY, () => {
                                this.createHorse(true); // Create from top
                            });
                            console.log(`Next horse scheduled to appear in ${this.NEW_HORSE_DELAY}ms`);
                        }
                    }

                    this.scheduleNextEggForHorse(horseId);
                });
            }

            hatchEgg(egg) {
                const hedleX = Phaser.Math.Clamp(egg.x, 80, this.gameWidth - 80);
                const hedleY = Phaser.Math.Clamp(egg.y, 80, this.gameHeight - 170); // Adjusted for new height

                const hedle = this.physics.add.sprite(hedleX, hedleY, `body_${egg.hedleId}_ft`);

                hedle.setDisplaySize(this.HEDLE_SIZE, this.HEDLE_SIZE);
                hedle.body.setSize(24, 32);
                hedle.body.setOffset(12, 16);
                hedle.setCollideWorldBounds(true);
                hedle.body.setBounce(1, 1);
                hedle.body.setMaxVelocity(this.HEDLE_SPEED, this.HEDLE_SPEED);

                hedle.hedleId = egg.hedleId;
                hedle.currentSprite = 'ft';
                hedle.isDying = false;
                hedle.isMoving = false;
                hedle.walkSpriteIndex = 0;
                hedle.direction = Phaser.Math.FloatBetween(Math.PI * 0.25, Math.PI * 0.75);

                this.hedles.add(hedle);
                this.createBobAnimation(hedle);
                this.startMovementCycle(hedle);
                hedle.isHedle = true; // Mark as hedle for message tracking
                this.scheduleHedleMessage(hedle);

                const index = this.eggs.indexOf(egg);
                if (index > -1) {
                    this.eggs.splice(index, 1);
                }

                egg.destroy();
            }

            createSpellInterface() {
                this.spellIcons = [];
                const slotY = this.gameHeight - 85; // Adjusted from gameHeight - 100
                const leftSlotX = [this.gameWidth / 2 - 280, this.gameWidth / 2 - 160];
                const rightSlotX = [this.gameWidth / 2 + 160, this.gameWidth / 2 + 280];

                for (let i = 0; i < 4; i++) {
                    const x = i < 2 ? leftSlotX[i] : rightSlotX[i - 2];

                    const icon = this.add.image(x, slotY, 'icon_blank');
                    icon.setDisplaySize(this.SPELL_SLOT_SIZE, this.SPELL_SLOT_SIZE);
                    icon.setInteractive();
                    icon.slotIndex = i;
                    icon.setDepth(200);

                    const border = this.add.graphics();
                    border.lineStyle(4, 0xFFD800);
                    border.strokeRect(
                        x - this.SPELL_SLOT_SIZE / 2,
                        slotY - this.SPELL_SLOT_SIZE / 2,
                        this.SPELL_SLOT_SIZE,
                        this.SPELL_SLOT_SIZE
                    );
                    border.setVisible(false);
                    border.setDepth(200);
                    icon.border = border;

                    icon.on('pointerdown', () => {
                        if (!this.gameOver && !this.isMultiShotting) {
                            this.uiClickThisFrame = true;
                            this.time.delayedCall(10, () => {
                                this.uiClickThisFrame = false;
                            });
                            this.selectSpell(i);
                        }
                    });

                    this.spellIcons.push(icon);
                }
            }

            updateScoreDisplay() {
                this.scoreDigits.forEach(digit => digit.destroy());
                this.scoreDigits = [];

                const scoreStr = this.score.toString();
                const numDigits = scoreStr.length;
                const digitWidth = 64;
                const digitHeight = this.DIGIT_SIZE;
                const totalWidth = numDigits * digitWidth;
                const startX = (this.gameWidth / 2) - (totalWidth / 2) + (digitWidth / 2);

                for (let i = 0; i < numDigits; i++) {
                    const digitValue = scoreStr[i];
                    const digitX = startX + (i * digitWidth);

                    const digitSprite = this.add.image(digitX, 60, `digit_${digitValue}`);
                    digitSprite.setDisplaySize(digitWidth, digitHeight);
                    digitSprite.setDepth(200);

                    this.scoreDigits.push(digitSprite);
                }
            }

            animateScoreChange() {
                this.scoreDigits.forEach(digit => {
                    this.tweens.add({
                        targets: digit,
                        scaleX: 1.2,
                        scaleY: 1.2,
                        duration: 120,
                        yoyo: true,
                        ease: 'Back.easeOut'
                    });
                });
            }

            // ALL THE OTHER GAME METHODS STAY EXACTLY THE SAME...
            // startFiring, stopFiring, attemptToFire, startCannonCharge, fireCannon, etc.

            startFiring() {
                if (this.gameOver) return;
                this.isFiring = true;
                this.attemptToFire();
            }

            stopFiring() {
                this.isFiring = false;
            }

            attemptToFire() {
                if (!this.isFiring || this.gameOver || this.isMultiShotting) return;

                if (!this.cannonCharging && !this.cannonOnCooldown) {
                    this.startCannonCharge();
                } else {
                    this.shotQueued = true;
                }
            }

            startCannonCharge() {
                if (this.isMultiShotting) return;

                this.cannonCharging = true;
                this.cannonChargeStart = this.time.now;

                this.chargeTimer = this.time.delayedCall(this.CANNON_CHARGE_TIME, () => {
                    if (this.cannonCharging && !this.gameOver) {
                        this.fireCannon();
                    }
                });
            }

            fireCannon() {
                this.shotQueued = false;

                if (this.selectedSpell !== null && this.spellSlots[this.selectedSpell] === 'multi') {
                    const spell = this.consumeSelectedSpell();
                    if (spell) {
                        this.fireMultiShot();
                        return;
                    }
                }

                const activeSpell = this.selectedSpell !== null ? this.spellSlots[this.selectedSpell] : null;

                if (this.cache.audio.exists('cannon_shot')) {
                    this.sound.play('cannon_shot');
                }

                this.cannonCharging = false;
                this.cannon.setTint(0xffffff);
                this.cannonOnCooldown = true;
                this.cannonCooldownStart = this.time.now;

                const cannonLength = this.CANNON_SIZE;
                const spawnOffsetX = Math.cos(this.cannonAngle) * (cannonLength * 0.8);
                const spawnOffsetY = Math.sin(this.cannonAngle) * (cannonLength * 0.8);

                const headNum = Phaser.Math.Between(1, this.HEAD_COUNT);
                const headId = headNum.toString().padStart(4, '0');

                const head = this.physics.add.sprite(
                    this.cannon.x + spawnOffsetX,
                    this.cannon.y + spawnOffsetY,
                    `head_${headId}`
                );

                this.heads.add(head);

                head.setDisplaySize(this.HEAD_SIZE, this.HEAD_SIZE);
                head.setOrigin(0.5, 0.25);
                head.body.setSize(18, 18);
                head.body.setOffset(16, 4);

                if (activeSpell) {
                    head.spellType = activeSpell;
                    head.hasHitHedle = false;
                    this.consumeSelectedSpell();

                    if (activeSpell === 'storm') {
                        head.isPiercing = true;
                        this.addStormTrail(head);
                    } else {
                        head.body.setBounce(1, 1);
                    }

                    if (activeSpell !== 'storm') {
                        const spellVisual = this.add.image(head.x, head.y, `spell_${activeSpell}`);
                        spellVisual.setDisplaySize(80, 80);
                        head.spellVisual = spellVisual;
                    }
                } else {
                    head.body.setBounce(1, 1);
                }

                head.body.setDrag(0);

                const velocityX = Math.cos(this.cannonAngle) * this.HEAD_SPEED;
                const velocityY = Math.sin(this.cannonAngle) * this.HEAD_SPEED;

                head.body.velocity.set(velocityX, velocityY);
            }

            selectSpell(index) {
                if (!this.spellSlots[index]) return;
                this.stopFiring();
                this.spellIcons.forEach(icon => {
                    icon.border.setVisible(false);
                });

                if (this.selectedSpell === index) {
                    this.selectedSpell = null;
                } else {
                    this.selectedSpell = index;
                    this.spellIcons[index].border.setVisible(true);
                }
            }

            consumeSelectedSpell() {
                if (this.selectedSpell === null) return null;

                const spell = this.spellSlots[this.selectedSpell];
                if (!spell) return null;

                this.spellSlots[this.selectedSpell] = null;
                this.spellIcons[this.selectedSpell].setTexture('icon_blank');
                this.spellIcons[this.selectedSpell].border.setVisible(false);

                const consumedSpell = spell;
                this.selectedSpell = null;

                return consumedSpell;
            }

            updateCannonAngle() {
                const cannonX = this.cannon.x;
                const cannonY = this.cannon.y;

                this.cannonAngle = Phaser.Math.Angle.Between(
                    cannonX, cannonY,
                    this.lastPointerPosition.x, this.lastPointerPosition.y
                );

                if (this.cannonAngle > 0) {
                    this.cannonAngle = 0;
                } else if (this.cannonAngle < -Math.PI) {
                    this.cannonAngle = -Math.PI;
                }

                this.cannon.setRotation(this.cannonAngle + Math.PI / 2);
            }

            createBobAnimation(hedle) {
                const currentScaleX = hedle.scaleX;
                const currentScaleY = hedle.scaleY;

                hedle.bobTween = this.tweens.add({
                    targets: hedle,
                    scaleY: currentScaleY * 1.02,
                    scaleX: currentScaleX * 0.98,
                    duration: 500,
                    yoyo: true,
                    repeat: -1,
                    ease: 'Sine.easeInOut'
                });
            }

            startMovementCycle(hedle) {
                if (hedle.isDying || !hedle.active) return;

                hedle.isMoving = true;
                hedle.walkSpriteIndex = 0;
                hedle.direction = Phaser.Math.FloatBetween(Math.PI * 0.25, Math.PI * 0.75);

                const velX = Math.cos(hedle.direction) * this.HEDLE_SPEED;
                const velY = Math.sin(hedle.direction) * this.HEDLE_SPEED;
                hedle.body.setVelocity(velX, velY);

                hedle.walkTimer = this.time.addEvent({
                    delay: this.HEDLE_WALK_SPRITE_INTERVAL,
                    callback: () => {
                        if (!hedle.isDying && hedle.active && hedle.isMoving) {
                            hedle.walkSpriteIndex = (hedle.walkSpriteIndex + 1) % 2;
                            const side = hedle.walkSpriteIndex === 0 ? 'L_sd' : 'R_sd';
                            hedle.setTexture(`body_${hedle.hedleId}_${side}`);
                        }
                    },
                    loop: true
                });

                hedle.moveCycleTimer = this.time.delayedCall(this.HEDLE_MOVE_TIME, () => {
                    if (hedle.isDying || !hedle.active) return;

                    hedle.isMoving = false;
                    hedle.body.setVelocity(0, 0);

                    if (hedle.walkTimer) hedle.walkTimer.destroy();
                    hedle.setTexture(`body_${hedle.hedleId}_ft`);

                    hedle.waitCycleTimer = this.time.delayedCall(this.HEDLE_WAIT_TIME, () => {
                        this.startMovementCycle(hedle);
                    });
                });
            }

            canHitHedle(head, hedle) {
                const speed = Math.sqrt(head.body.velocity.x ** 2 + head.body.velocity.y ** 2);
                return speed >= this.MIN_HEAD_DAMAGE_SPEED && !hedle.isDying;
            }

            // Unified hedle death method
            killHedle(hedle, impactX = null, impactY = null) {
                if (hedle.isDying) return;

                // Create impact sparks at specified location or hedle center
                const sparkX = impactX !== null ? impactX : hedle.x;
                const sparkY = impactY !== null ? impactY : hedle.y;
                this.createImpactSparks(sparkX, sparkY);

                hedle.isDying = true;
                if (hedle.dangerParticles) {
                    hedle.dangerParticles.destroy();
                    hedle.dangerParticles = null;
                }

                const owwSounds = ['oww_1', 'oww_2', 'oww_3', 'oww_4'];
                const randomOww = Phaser.Utils.Array.GetRandom(owwSounds);
                if (this.cache.audio.exists(randomOww)) {
                    this.sound.play(randomOww);
                }

                // Cleanup hedle message timer and freeze floating texts
                if (hedle.messageTimer) {
                    hedle.messageTimer.destroy();
                }
                if (this.floatingTexts) {
                    this.floatingTexts.forEach(text => {
                        if (text.followEntity === hedle && text.active) {
                            text.frozenX = text.x;
                            text.frozenY = text.y;
                            text.followEntity = null;
                        }
                    });
                }

                // Clean up all timers and animations
                if (hedle.walkTimer) hedle.walkTimer.destroy();
                if (hedle.bobTween) hedle.bobTween.destroy();
                if (hedle.moveCycleTimer) hedle.moveCycleTimer.destroy();
                if (hedle.waitCycleTimer) hedle.waitCycleTimer.destroy();

                hedle.body.setVelocity(0, 0);
                hedle.body.enable = false;

                // Set up rotation animation (adjust origin and position)
                const currentY = hedle.y;
                hedle.setOrigin(0.5, 1);
                hedle.y = currentY + (hedle.displayHeight / 2);

                const fallDirection = Phaser.Math.Between(0, 1) === 0 ? -1 : 1;

                this.tweens.add({
                    targets: hedle,
                    rotation: (Math.PI / 2) * fallDirection,
                    alpha: 0,
                    duration: 400,
                    onComplete: () => hedle.destroy()
                });

                this.score++;
                this.updateScoreDisplay();
                this.animateScoreChange();
            }

            // Simplified hitHedle method - focuses on collision logic
            hitHedle(head, hedle) {
                if (hedle.isDying) return;

                // Calculate the actual collision point between head and hedle
                const impactX = (head.x + hedle.x) / 2;
                const impactY = (head.y + hedle.y) / 2;

                if (head.spellType || head.multiVisual) {
                    head.hasHitHedle = true;
                }

                // Handle spell effects
                if (head.spellType) {
                    if (head.spellType === 'fire') {
                        this.executeFireSpell(head.x, head.y);
                        if (head.spellVisual && head.spellVisual.active) {
                            head.spellVisual.destroy();
                        }
                    } else if (head.spellType === 'water') {
                        this.executeWaterSpell(head.x, head.y);
                        if (head.spellVisual && head.spellVisual.active) {
                            head.spellVisual.destroy();
                        }
                    }

                    if (head.spellType !== 'storm') {
                        head.spellType = null;
                    }
                }

                // Kill the hedle with impact sparks at collision point
                this.killHedle(hedle, impactX, impactY);

                // Handle head bouncing/slowing
                if (!head.isPiercing) {
                    const currentSpeed = Math.sqrt(head.body.velocity.x ** 2 + head.body.velocity.y ** 2);
                    const newSpeed = currentSpeed * 0.5;
                    const bounceAngle = Phaser.Math.FloatBetween(0, Math.PI * 2);
                    const newVelX = Math.cos(bounceAngle) * newSpeed;
                    const newVelY = Math.sin(bounceAngle) * newSpeed;
                    head.body.setVelocity(newVelX, newVelY);
                }
            }


            headCollision(head1, head2) {
                if (this.cache.audio.exists('ball_bounce')) {
                    this.sound.play('ball_bounce');
                }
            }

            canHeadsCollide(head1, head2) {
                const head1IsSpecial = head1.spellType || head1.multiVisual;
                const head2IsSpecial = head2.spellType || head2.multiVisual;

                if (!head1IsSpecial && !head2IsSpecial) {
                    return true;
                }

                if ((head1IsSpecial && head1.spellType === 'storm') ||
                    (head2IsSpecial && head2.spellType === 'storm')) {
                    return false;
                }

                if (head1IsSpecial && head1.hasHitHedle === false) {
                    return false;
                }
                if (head2IsSpecial && head2.hasHitHedle === false) {
                    return false;
                }

                return true;
            }

            checkGameOver() {
                this.hedles.children.entries.forEach(hedle => {
                    if (!hedle.isDying && hedle.y > this.gameHeight - 135) { // Adjusted for new height
                        this.endGame();
                    }
                });
            }

            // Use shared text wrapping in game over but keep all the original game over logic
            createGameOverTypewriter(x, y, callback) {
                const message = Phaser.Utils.Array.GetRandom(this.gameOverMessages);

                const fontFamily = '"Press Start 2P", "Press Start 2P Local", monospace';
                const fontSize = this.fontLoaded ? '32px' : '36px';

                const wrapWidth = this.gameWidth * 0.96;

                // Use shared text wrapping utility
                const wrappedMessage = SharedUtils.wrapText(message, fontFamily, fontSize, wrapWidth, this);

                this.gameOverMessage = this.add.text(x, y, '', {
                    fontFamily: fontFamily,
                    fontSize: fontSize,
                    fill: '#ff0000',
                    align: 'center'
                });
                this.gameOverMessage.setOrigin(0.5);
                this.gameOverMessage.setDepth(200);

                this.gameOverTyping = true;
                this.gameOverCanAdvance = false;
                this.gameOverWrappedText = wrappedMessage;

                let currentText = '';
                let charIndex = 0;
                const typewriterSpeed = 80;

                const typeNextChar = () => {
                    if (charIndex < wrappedMessage.length && this.gameOverTyping) {
                        currentText += wrappedMessage[charIndex];
                        this.gameOverMessage.setText(currentText);

                        if (wrappedMessage[charIndex] !== ' ' && wrappedMessage[charIndex] !== '\n' && this.typewriterSounds.length > 0) {
                            const randomSound = Phaser.Utils.Array.GetRandom(this.typewriterSounds);
                            this.sound.play(randomSound, { volume: 0.3 });
                        }

                        charIndex++;
                        this.typewriterTimer = this.time.delayedCall(typewriterSpeed, typeNextChar);
                    } else {
                        this.completeGameOverTypewriter(callback);
                    }
                };

                const gameOverAdvanceHandler = () => {
                    if (this.gameOverTyping) {
                        this.completeGameOverTypewriter(callback, true);
                    } else if (this.gameOverCanAdvance) {
                        this.handleGameOverComplete(callback);
                    }
                };

                this.input.off('pointerdown', this.gameOverPointerHandler);
                this.gameOverPointerHandler = gameOverAdvanceHandler;
                this.input.on('pointerdown', this.gameOverPointerHandler);

                if (this.gameOverSpaceKey) {
                    this.gameOverSpaceKey.off('down');
                }
                this.gameOverSpaceKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);
                this.gameOverSpaceKey.on('down', gameOverAdvanceHandler);

                typeNextChar();
            }

            completeGameOverTypewriter(callback, wasSkipped = false) {
                this.gameOverTyping = false;
                this.gameOverCanAdvance = true;

                if (this.typewriterTimer) {
                    this.typewriterTimer.destroy();
                }

                this.gameOverMessage.setText(this.gameOverWrappedText);

                if (wasSkipped) {
                    this.time.delayedCall(500, () => {
                        this.handleGameOverComplete(callback);
                    });
                } else {
                    this.time.delayedCall(1500, () => {
                        this.handleGameOverComplete(callback);
                    });
                }
            }

            handleGameOverComplete(callback) {
                this.input.off('pointerdown', this.gameOverPointerHandler);
                if (this.gameOverSpaceKey) {
                    this.gameOverSpaceKey.off('down');
                }

                this.time.delayedCall(2000, () => {
                    if (callback) callback();
                });
            }

            createGameOverPlayButton(x, y) {
                this.gameOverPlayButton = this.add.image(x, y, 'click_play');
                this.gameOverPlayButton.setDisplaySize(384, 192);
                this.gameOverPlayButton.setInteractive();
                this.gameOverPlayButton.setDepth(200);

                this.gameOverPlayButton.on('pointerover', () => {
                    this.gameOverPlayButton.setTint(0xcccccc);
                });
                this.gameOverPlayButton.on('pointerout', () => {
                    this.gameOverPlayButton.setTint(0xffffff);
                });
                this.gameOverPlayButton.on('pointerdown', () => {
                    SharedUtils.buttonPress(this, this.gameOverPlayButton, 'click_play2', () => {
                        this.scene.restart();
                    });

                    // Farcade SDK: Hide our play button since Farcade UI takes over
                    if (window.FarcadeSDK) {
                        this.gameOverPlayButton.setVisible(false);
                    }
                });
            }

            scheduleBat() {
                if (this.gameOver) return;

                this.batTimer = this.time.delayedCall(this.currentBatDelay, () => {
                    this.spawnBat();
                    this.currentBatDelay += this.batDelayIncrement;
                    this.scheduleBat();
                });
            }

            spawnBat() {
                if (this.gameOver) return;

                const minY = this.gameHeight * 0.2;
                const maxY = this.gameHeight * 0.8;
                const batY = Phaser.Math.Between(minY, maxY);

                const goingRight = Phaser.Math.Between(0, 1) === 1;
                const startX = goingRight ? -150 : this.gameWidth + 150;
                const endX = goingRight ? this.gameWidth + 150 : -150;

                const bat = this.add.sprite(startX, batY, 'bat_1');
                bat.setDisplaySize(180, 180);
                bat.setDepth(300);

                if (!goingRight) {
                    bat.setFlipX(true);
                }

                const batParticles = this.add.particles(startX, batY, 'golden_dot', {
                    scale: { start: 0.6, end: 0.2 },
                    alpha: { start: 1.0, end: 0.2 },
                    speed: { min: 40, max: 80 },
                    lifespan: 2000,
                    frequency: 100,
                    quantity: 2,
                    emitZone: {
                        type: 'random',
                        source: new Phaser.Geom.Circle(0, 0, 64),
                        quantity: 2
                    }
                });
                batParticles.setDepth(300);

                let batFrame = 0;
                const batFrames = ['bat_1', 'bat_2', 'bat_3', 'bat_4'];
                bat.animTimer = this.time.addEvent({
                    delay: 100,
                    callback: () => {
                        batFrame = (batFrame + 1) % 4;
                        bat.setTexture(batFrames[batFrame]);
                    },
                    loop: true
                });

                const bookTypes = ['fire', 'water', 'storm', 'multi'];
                const bookType = Phaser.Utils.Array.GetRandom(bookTypes);
                const book = this.add.image(startX, batY + 60, `tome_${bookType}`);
                book.setDisplaySize(90, 90);
                book.setInteractive();
                book.bookType = bookType;
                book.setDepth(300);
                this.scheduleBatMessage(bat);

                book.on('pointerdown', () => {
                    this.uiClickThisFrame = true;
                    this.time.delayedCall(10, () => {
                        this.uiClickThisFrame = false;
                    });

                    if (this.addSpellToSlot(bookType)) {
                        if (this.cache.audio.exists('pickup_spell')) {
                            this.sound.play('pickup_spell');
                        }

                        book.destroy();
                        const collected = this.add.text(book.x, book.y, `+${bookType.toUpperCase()}`, {
                            fontSize: '32px',
                            fill: '#FFD800'
                        }).setOrigin(0.5);

                        this.tweens.add({
                            targets: collected,
                            y: collected.y - 50,
                            alpha: 0,
                            duration: 1000,
                            onComplete: () => collected.destroy()
                        });
                    }
                });

                this.tweens.add({
                    targets: [bat, book, batParticles],
                    x: endX,
                    duration: this.gameWidth / this.BAT_SPEED * 1000,
                    onComplete: () => {
                        if (bat.messageTimer) {
                            bat.messageTimer.destroy();
                        }
                        if (bat.animTimer) bat.animTimer.destroy();
                        bat.destroy();
                        if (book.active) book.destroy();
                        batParticles.destroy();
                    }
                });
            }

            addSpellToSlot(spellType) {
                const emptyIndex = this.spellSlots.indexOf(null);
                if (emptyIndex === -1) return false;

                this.spellSlots[emptyIndex] = spellType;
                this.spellIcons[emptyIndex].setTexture(`icon_${spellType}`);

                return true;
            }

            // [Continue with ALL other methods exactly as they were...]
            // executeFireSpell, executeWaterSpell, addStormTrail, fireMultiShot, etc.

            update(time, delta) {
                if (this.gameOver) return;

                // CRITICAL: Keep the horse movement update!
                this.updateHorseMovement();

                if (this.cannonOnCooldown) {
                    const elapsed = this.time.now - this.cannonCooldownStart;
                    if (elapsed >= this.CANNON_COOLDOWN_TIME) {
                        this.cannonOnCooldown = false;
                        if (this.shotQueued && !this.isMultiShotting) {
                            this.shotQueued = false;
                            this.startCannonCharge();
                        } else if (this.isFiring && !this.isMultiShotting) {
                            this.attemptToFire();
                        }
                    }
                }

                if (this.cannonCharging) {
                    const chargeProgress = (this.time.now - this.cannonChargeStart) / this.CANNON_CHARGE_TIME;
                    const shakeIntensity = Math.min(chargeProgress * 10, 10);

                    this.cannon.x = this.gameWidth / 2 + (Math.random() - 0.5) * shakeIntensity;
                    this.cannon.y = this.gameHeight - 85 + (Math.random() - 0.5) * shakeIntensity; // Adjusted
                    this.cannon.setTint(0xff4444);
                } else {
                    this.cannon.x = this.gameWidth / 2;
                    this.cannon.y = this.gameHeight - 85; // Adjusted

                    if (this.selectedSpell !== null && this.spellSlots[this.selectedSpell]) {
                        const spellType = this.spellSlots[this.selectedSpell];
                        if (spellType === 'fire') {
                            this.cannon.setTint(0xff6600);
                        } else if (spellType === 'water') {
                            this.cannon.setTint(0x0099ff);
                        } else if (spellType === 'storm') {
                            this.cannon.setTint(0x9900ff);
                        } else if (spellType === 'multi') {
                            this.cannon.setTint(0x00ff00);
                        }
                    } else {
                        this.cannon.setTint(0xffffff);
                    }
                }

                this.heads.children.entries.forEach(head => {
                    if (head.spellVisual && head.spellVisual.active) {
                        head.spellVisual.x = head.x;
                        head.spellVisual.y = head.y;
                    }
                    if (head.multiVisual && head.multiVisual.active) {
                        head.multiVisual.x = head.x;
                        head.multiVisual.y = head.y;
                    }

                    if (head.body) {
                        const speed = Math.sqrt(head.body.velocity.x ** 2 + head.body.velocity.y ** 2);
                        const rotationSpeed = speed * 0.008;
                        head.rotation += rotationSpeed * delta * 0.001;
                    }
                });

                if (this.floatingTexts) {
                    this.floatingTexts.forEach(floatingText => {
                        if (floatingText.active && floatingText.followEntity && floatingText.followEntity.active) {
                            floatingText.x = floatingText.followEntity.x;
                            floatingText.y = floatingText.followEntity.y + floatingText.baseOffsetY + floatingText.floatOffsetY;
                        }
                    });
                }

                this.updateScreenFade(delta);

                this.hedles.children.entries.forEach(hedle => {
                    if (!hedle.isDying && hedle.isMoving) {
                        if (hedle.x < 40) {
                            hedle.x = 40;
                            hedle.body.setVelocityX(Math.abs(hedle.body.velocity.x));
                        } else if (hedle.x > this.gameWidth - 40) {
                            hedle.x = this.gameWidth - 40;
                            hedle.body.setVelocityX(-Math.abs(hedle.body.velocity.x));
                        }

                        if (hedle.y < 40) {
                            hedle.y = 40;
                            hedle.body.setVelocityY(Math.abs(hedle.body.velocity.y));
                        }
                    }

                    // Danger zone red particles (bottom of screen) - adjusted for new height
                    if (!hedle.isDying) {
                        const dangerZone = this.gameHeight * 0.75;
                        const isInDanger = hedle.y > dangerZone;

                        if (isInDanger && !hedle.dangerParticles) {
                            hedle.dangerParticles = this.add.particles(hedle.x, hedle.y, 'red_dot', {
                                scale: { start: 0.8, end: 0.2 },
                                alpha: { start: 0.8, end: 0.1 },
                                speed: { min: 20, max: 40 },
                                lifespan: 800,
                                frequency: 80,
                                quantity: 4,
                                emitZone: {
                                    type: 'random',
                                    source: new Phaser.Geom.Circle(0, 0, 64),
                                    quantity: 2
                                }
                            });
                            hedle.dangerParticles.setDepth(140);

                        } else if (!isInDanger && hedle.dangerParticles) {
                            hedle.dangerParticles.destroy();
                            hedle.dangerParticles = null;
                        }

                        if (hedle.dangerParticles) {
                            hedle.dangerParticles.x = hedle.x;
                            hedle.dangerParticles.y = hedle.y;
                        }
                    }
                });

                // Check persistent water line collisions
                this.activeWaterLines = this.activeWaterLines.filter(line => {
                    if (this.time.now > line.expiresAt) return false;

                    this.hedles.children.entries.forEach(hedle => {
                        if (!hedle.isDying) {
                            const distToLine = this.distanceToLine(hedle,
                                { x: line.x1, y: line.y1 },
                                { x: line.x2, y: line.y2 });
                            if (distToLine <= 40) {
                                this.killHedle(hedle);
                            }
                        }
                    });
                    return true;
                });

                // Cleanup heads
                this.heads.children.entries.forEach(head => {
                    if (head.x < -200 || head.x > this.gameWidth + 200 ||
                        head.y < -200 || head.y > this.gameHeight + 200) {
                        this.cleanupHead(head);
                    }
                });

                this.checkGameOver();
            }

            updateScreenFade(delta) {
                if (!this.gameOverFadeOverlay) return;

                this.fadeUpdateCounter++;
                if (this.fadeUpdateCounter < 4) return;
                this.fadeUpdateCounter = 0;

                let maxThreatLevel = 0;

                this.hedles.children.entries.forEach(hedle => {
                    if (!hedle.isDying) {
                        const threatZoneStart = this.gameHeight * 0.2;
                        const gameOverZone = this.gameHeight - 135; // Adjusted for new height

                        if (hedle.y > threatZoneStart) {
                            const threatLevel = Math.min((hedle.y - threatZoneStart) / (gameOverZone - threatZoneStart), 1);
                            maxThreatLevel = Math.max(maxThreatLevel, threatLevel);
                        }
                    }
                });

                const newTargetOpacity = maxThreatLevel * 0.8;

                if (newTargetOpacity !== this.targetFadeOpacity ||
                    Math.abs(this.currentFadeOpacity - this.targetFadeOpacity) > 0.01) {

                    this.targetFadeOpacity = newTargetOpacity;

                    const deltaSeconds = (delta * 4) * 0.001;
                    const transitionAmount = this.fadeTransitionSpeed * deltaSeconds;

                    if (this.currentFadeOpacity < this.targetFadeOpacity) {
                        this.currentFadeOpacity = Math.min(
                            this.currentFadeOpacity + transitionAmount * 1.2,
                            this.targetFadeOpacity
                        );
                    } else if (this.currentFadeOpacity > this.targetFadeOpacity) {
                        this.currentFadeOpacity = Math.max(
                            this.currentFadeOpacity - transitionAmount * 0.8,
                            this.targetFadeOpacity
                        );
                    }

                    this.gameOverFadeOverlay.clear();
                    if (this.currentFadeOpacity > 0) {
                        this.gameOverFadeOverlay.fillStyle(0x000000, this.currentFadeOpacity);
                        this.gameOverFadeOverlay.fillRect(0, 0, this.gameWidth, this.gameHeight);
                    }
                }
            }

            createFloatingText(entity, messages, offsetY = -32) {
                if (this.gameOver || !entity.active) return;

                // Check hedle message limit
                if (entity.isHedle && this.activeHedleMessages >= this.MAX_HEDLE_MESSAGES) return;

                const message = Phaser.Utils.Array.GetRandom(messages);

                const floatingText = this.add.text(
                    entity.x,
                    entity.y + offsetY,
                    message,
                    {
                        fontFamily: '"Press Start 2P", "Press Start 2P Local", monospace',
                        fontSize: this.fontLoaded ? '24px' : '32px',
                        fill: '#ffffff',
                        align: 'center',
                        stroke: '#000000',
                        strokeThickness: 2
                    }
                );

                floatingText.setOrigin(0.5);
                floatingText.setDepth(350);
                floatingText.setAlpha(0);

                // Store entity reference and offset for following
                floatingText.followEntity = entity;
                floatingText.baseOffsetY = offsetY;
                floatingText.floatOffsetY = 0; // Additional offset from floating animation

                // Track hedle messages
                if (entity.isHedle) {
                    this.activeHedleMessages++;
                    floatingText.isHedleMessage = true;
                }

                // Add to floating texts array for update tracking
                if (!this.floatingTexts) {
                    this.floatingTexts = [];
                }
                this.floatingTexts.push(floatingText);

                // Fade in
                this.tweens.add({
                    targets: floatingText,
                    alpha: 1,
                    duration: 300,
                    ease: 'Power2'
                });

                // Float upward slightly
                this.tweens.add({
                    targets: floatingText,
                    floatOffsetY: -20,
                    duration: 2000,
                    ease: 'Sine.easeOut'
                });

                // Fade out and destroy after 2 seconds
                this.time.delayedCall(2000, () => {
                    if (floatingText.active) {
                        this.tweens.add({
                            targets: floatingText,
                            alpha: 0,
                            duration: 500,
                            ease: 'Power2',
                            onComplete: () => {
                                if (floatingText.isHedleMessage) {
                                    this.activeHedleMessages = Math.max(0, this.activeHedleMessages - 1);
                                }

                                // Remove from floating texts array
                                const index = this.floatingTexts?.indexOf(floatingText);
                                if (index > -1) {
                                    this.floatingTexts.splice(index, 1);
                                }

                                floatingText.destroy();
                            }
                        });
                    }
                });

                return floatingText;
            }

            scheduleHedleMessage(hedle) {
                if (this.gameOver || !hedle.active || hedle.isDying) return;

                // messageChance every checkInterval seconds
                const checkInterval = 4000;
                const messageChance = 0.5;

                hedle.messageTimer = this.time.addEvent({
                    delay: checkInterval,
                    callback: () => {
                        if (!this.gameOver && hedle.active && !hedle.isDying) {
                            if (Math.random() < messageChance) {
                                this.createFloatingText(hedle, this.hedleMessages, -32);
                            }
                        }
                    },
                    loop: true
                });
            }

            scheduleBatMessage(bat) {
                if (this.gameOver || !bat.active) return;

                // chance the bat will say something during its flight
                if (Math.random() < 0.8) {
                    // Random delay between 500ms and 2000ms after bat appears
                    const messageDelay = Phaser.Math.Between(500, 2000);

                    bat.messageTimer = this.time.delayedCall(messageDelay, () => {
                        if (!this.gameOver && bat.active) {
                            this.createFloatingText(bat, this.batMessages, -32);
                        }
                    });
                }
            }

            endGame() {
                if (this.gameOver) return;

                this.gameOver = true;
                this.stopFiring();

                if (this.backgroundMusic && this.backgroundMusic.isPlaying) {
                    this.backgroundMusic.stop();
                }

                if (this.eggSpawnTimer) this.eggSpawnTimer.destroy();
                if (this.chargeTimer) this.chargeTimer.destroy();
                if (this.batTimer) this.batTimer.destroy();
                if (this.horseWalkTimer) this.horseWalkTimer.destroy();

                if (this.horse && this.horse.active) {
                    this.horseVelocityX = 0;
                    this.horseVelocityY = 0;
                    this.horseIsLaying = false;
                }

                this.horses.forEach(horse => {
                    if (horse.walkTimer) horse.walkTimer.destroy();
                });
                this.horseSpawnData.forEach(spawnData => {
                    if (spawnData.spawnTimer) spawnData.spawnTimer.destroy();
                });
                this.horses = [];
                this.horseSpawnData = [];

                this.hedles.children.entries.forEach(hedle => {
                    if (hedle.body) hedle.body.setVelocity(0, 0);
                    if (hedle.walkTimer) hedle.walkTimer.destroy();
                    if (hedle.bobTween) hedle.bobTween.destroy();
                    if (hedle.moveCycleTimer) hedle.moveCycleTimer.destroy();
                    if (hedle.waitCycleTimer) hedle.waitCycleTimer.destroy();
                });

                this.eggs.forEach(egg => {
                    for (let i = 1; i <= 4; i++) {
                        if (egg[`growthTimer${i}`]) egg[`growthTimer${i}`].destroy();
                    }
                    if (egg.hatchTimer) egg.hatchTimer.destroy();
                    egg.destroy();
                });
                this.eggs = [];

                this.heads.children.entries.forEach(head => {
                    this.cleanupHead(head);
                });

                if (this.spellIcons) {
                    this.spellIcons.forEach(icon => {
                        icon.setVisible(false);
                        if (icon.border) icon.border.setVisible(false);
                    });
                }

                this.activeWaterLines = [];

                this.scoreDigits.forEach(digit => {
                    this.tweens.add({
                        targets: digit,
                        scaleX: 1.1,
                        scaleY: 1.1,
                        duration: 1000,
                        yoyo: true,
                        repeat: -1,
                        ease: 'Sine.easeInOut'
                    });
                });

                this.createGameOverTypewriter(
                    this.gameWidth / 2,
                    this.gameHeight / 2,
                    () => {
                        // Farcade SDK: Call gameOver with score when play button appears
                        if (window.FarcadeSDK) {
                            window.FarcadeSDK.singlePlayer.actions.gameOver({ score: this.score });
                            console.log('Farcade SDK: Game over signal sent with score:', this.score);
                        }

                        this.createGameOverPlayButton(
                            this.gameWidth / 2,
                            this.gameHeight / 2 + 170 // Adjusted for new height
                        );
                    }
                );
            }

            cleanupHead(head) {
                if (head.trailTimer) head.trailTimer.destroy();
                if (head.spellVisual && head.spellVisual.active) head.spellVisual.destroy();
                if (head.multiVisual && head.multiVisual.active) head.multiVisual.destroy();
                head.destroy();
            }

            // KEEP ALL REMAINING METHODS EXACTLY AS THEY WERE...
            // Adding the essential ones that are called but not yet defined

            executeFireSpell(x, y) {
                const numExplosions = 16;
                for (let i = 0; i < numExplosions; i++) {
                    const angle = (i / numExplosions) * Math.PI * 2;
                    const explosionX = x + Math.cos(angle) * this.FIRE_EXPLOSION_RADIUS;
                    const explosionY = y + Math.sin(angle) * this.FIRE_EXPLOSION_RADIUS;

                    const explosion = this.add.image(explosionX, explosionY, 'spell_fire');
                    explosion.setDisplaySize(80, 80);

                    this.tweens.add({
                        targets: explosion,
                        alpha: 0,
                        scaleX: 1.5,
                        scaleY: 1.5,
                        duration: 1000,
                        onComplete: () => explosion.destroy()
                    });
                }

                this.hedles.children.entries.forEach(hedle => {
                    if (!hedle.isDying) {
                        const distance = Phaser.Math.Distance.Between(x, y, hedle.x, hedle.y);
                        if (distance <= this.FIRE_EXPLOSION_RADIUS) {
                            // Use unified kill method (sparks will appear at hedle center)
                            this.killHedle(hedle);
                        }
                    }
                });
            }

            executeWaterSpell(x, y) {
                const angle = 0; // Always horizontal
                const waterLineLength = 256;
                const numSegments = 8; // 256px / 32px per segment

                // Create visual sprites
                const waveLength = 128; // Wavelength for the traveling wave
                for (let i = 0; i < numSegments; i++) {
                    const segmentDist = (i / numSegments) * waterLineLength - waterLineLength / 2;
                    const waterX = x + segmentDist;
                    const waterY = y;

                    const water = this.add.image(waterX, waterY, 'spell_water');
                    water.setDisplaySize(60, 60);

                    // Traveling wave motion
                    const wavePhase = (Math.abs(segmentDist) % waveLength) / waveLength * Math.PI * 2;
                    const waveAmplitude = 25;
                    const waveFrequency = 800;

                    this.tweens.add({
                        targets: water,
                        y: waterY + waveAmplitude,
                        duration: waveFrequency / 2,
                        delay: wavePhase * 100,
                        yoyo: true,
                        repeat: 15, // ~8 seconds of wave motion
                        ease: 'Sine.easeInOut'
                    });

                    // Fade only in the last second
                    this.tweens.add({
                        targets: water,
                        alpha: 0,
                        duration: 1000,
                        delay: 7000, // Start fading after 7 seconds
                        onComplete: () => water.destroy()
                    });
                }

                // Store collision line
                const waterLine = {
                    x1: x - waterLineLength / 2,
                    y1: y,
                    x2: x + waterLineLength / 2,
                    y2: y,
                    expiresAt: this.time.now + 8000
                };

                this.activeWaterLines.push(waterLine);
            }

            distanceToLine(point, lineStart, lineEnd) {
                const A = point.x - lineStart.x;
                const B = point.y - lineStart.y;
                const C = lineEnd.x - lineStart.x;
                const D = lineEnd.y - lineStart.y;

                const dot = A * C + B * D;
                const lenSq = C * C + D * D;
                let param = -1;

                if (lenSq !== 0) param = dot / lenSq;

                let xx, yy;

                if (param < 0) {
                    xx = lineStart.x;
                    yy = lineStart.y;
                } else if (param > 1) {
                    xx = lineEnd.x;
                    yy = lineEnd.y;
                } else {
                    xx = lineStart.x + param * C;
                    yy = lineStart.y + param * D;
                }

                const dx = point.x - xx;
                const dy = point.y - yy;

                return Math.sqrt(dx * dx + dy * dy);
            }

            addStormTrail(head) {
                head.trailTimer = this.time.addEvent({
                    delay: 50,
                    callback: () => {
                        if (!head.active) {
                            head.trailTimer.destroy();
                            return;
                        }

                        const trail = this.add.image(head.x, head.y, 'spell_storm');
                        trail.setDisplaySize(60, 60);
                        trail.setAlpha(0.8);

                        this.tweens.add({
                            targets: trail,
                            alpha: 0,
                            duration: 500,
                            onComplete: () => trail.destroy()
                        });
                    },
                    loop: true
                });
            }

            fireMultiShot() {
                this.isMultiShotting = true;
                this.shotQueued = false;
                let shotCount = 0;

                const shootNext = () => {
                    if (shotCount >= this.MULTI_SHOT_COUNT || this.gameOver) {
                        this.isMultiShotting = false;
                        return;
                    }

                    if (this.cache.audio.exists('cannon_shot')) {
                        this.sound.play('cannon_shot');
                    }

                    const cannonLength = this.CANNON_SIZE;
                    const spawnOffsetX = Math.cos(this.cannonAngle) * (cannonLength * 0.8);
                    const spawnOffsetY = Math.sin(this.cannonAngle) * (cannonLength * 0.8);

                    const headNum = Phaser.Math.Between(1, this.HEAD_COUNT);
                    const headId = headNum.toString().padStart(4, '0');

                    const head = this.physics.add.sprite(
                        this.cannon.x + spawnOffsetX,
                        this.cannon.y + spawnOffsetY,
                        `head_${headId}`
                    );

                    this.heads.add(head);
                    head.setDisplaySize(this.HEAD_SIZE, this.HEAD_SIZE);
                    head.setOrigin(0.5, 0.25);
                    head.body.setSize(18, 18);
                    head.body.setOffset(16, 4);
                    head.body.setBounce(1, 1);
                    head.body.setDrag(0);

                    head.hasHitHedle = false;

                    const spellVisual = this.add.image(head.x, head.y, 'spell_multi');
                    spellVisual.setDisplaySize(60, 60);
                    head.multiVisual = spellVisual;

                    this.tweens.add({
                        targets: spellVisual,
                        alpha: 0,
                        duration: 1000,
                        onComplete: () => spellVisual.destroy()
                    });

                    const velocityX = Math.cos(this.cannonAngle) * this.HEAD_SPEED;
                    const velocityY = Math.sin(this.cannonAngle) * this.HEAD_SPEED;
                    head.body.velocity.set(velocityX, velocityY);

                    shotCount++;

                    this.time.delayedCall(this.MULTI_SHOT_DELAY, shootNext);
                };

                this.cannonCharging = false;
                this.cannon.setTint(0xffffff);

                shootNext();
            }
        }

        // Game configuration - Updated for 2:3 aspect ratio
        const config = {
            type: Phaser.AUTO,
            width: 900,
            height: 1350, // Changed from 1600
            parent: 'game-container',
            physics: {
                default: 'arcade',
                arcade: {
                    gravity: { y: 0 },
                    debug: false
                }
            },
            scene: [StartScreen, StoryScreen, GameScreen],
            scale: {
                mode: Phaser.Scale.FIT,
                autoCenter: Phaser.Scale.CENTER_BOTH
            }
        };

        const game = new Phaser.Game(config);

        // Farcade SDK: Register event handlers for 'play_again' and 'toggle_mute'
        if (window.FarcadeSDK) {
            // Handle play again requests from Farcade
            window.FarcadeSDK.on('play_again', () => {
                console.log('Farcade SDK: Play again requested.');
                const gameScene = game.scene.getScene('GameScreen');
                if (gameScene) {
                    // Stop background music if playing
                    if (gameScene.backgroundMusic && gameScene.backgroundMusic.isPlaying) {
                        gameScene.backgroundMusic.stop();
                    }
                    // Restart the game scene
                    game.scene.start('GameScreen');
                    console.log('Farcade SDK: Game restarted.');
                } else {
                    // Fallback: restart from start screen
                    game.scene.start('StartScreen');
                    console.log('Farcade SDK: Restarted from start screen.');
                }
            });

            // Handle mute/unmute requests from Farcade
            window.FarcadeSDK.on('toggle_mute', (data) => {
                console.log('Farcade SDK: Mute toggle requested, isMuted:', data.isMuted);
                // Use Phaser's global sound manager to mute/unmute all audio
                game.sound.mute = data.isMuted;
                console.log('Farcade SDK: All game audio mute state set to:', data.isMuted);
            });

            console.log('Farcade SDK: Event handlers registered.');
        }

        // L Pattern Background System - Golden border and intertwined L patterns
        const LPatternBackgroundSystem = {
            patternCanvas: null,
            borderCanvas: null,
            isInitialized: false,

            // Configuration
            config: {
                size: 6,
                thickness: 4,
                spacing: 4,
                color: '#FFD700',
                opacity: 0.5,
                borderWidth: 8
            },

            // Initialize the L pattern background
            init: function () {
                if (this.isInitialized) return;

                console.log("Initializing L pattern background...");

                // Create canvases
                this.createCanvases();

                // Draw the pattern immediately
                this.drawPattern();

                // Wait for Phaser canvas to be ready, then handle borders
                setTimeout(() => {
                    this.updateBorders();
                }, 20);

                // Listen for window resize
                window.addEventListener('resize', () => this.handleResize());

                this.isInitialized = true;
                console.log("L pattern background initialized");
            },

            // Create separate canvases for pattern and border
            createCanvases: function () {
                // Safety check: ensure valid viewport dimensions
                if (window.innerWidth <= 0 || window.innerHeight <= 0) {
                    console.warn('Invalid viewport dimensions, delaying canvas creation');
                    setTimeout(() => this.createCanvases(), 50);
                    return;
                }

                // Create pattern canvas
                this.patternCanvas = document.createElement('canvas');
                this.patternCanvas.id = 'l-pattern-background';
                this.patternCanvas.style.position = 'fixed';
                this.patternCanvas.style.top = '0';
                this.patternCanvas.style.left = '0';
                this.patternCanvas.style.width = '100vw';
                this.patternCanvas.style.height = '100vh';
                this.patternCanvas.style.zIndex = '-1000';
                this.patternCanvas.style.pointerEvents = 'none';
                this.patternCanvas.style.opacity = this.config.opacity;
                this.patternCanvas.width = window.innerWidth;
                this.patternCanvas.height = window.innerHeight;
                document.body.appendChild(this.patternCanvas);

                // Create border canvas (full opacity)
                this.borderCanvas = document.createElement('canvas');
                this.borderCanvas.id = 'l-border-background';
                this.borderCanvas.style.position = 'fixed';
                this.borderCanvas.style.top = '0';
                this.borderCanvas.style.left = '0';
                this.borderCanvas.style.width = '100vw';
                this.borderCanvas.style.height = '100vh';
                this.borderCanvas.style.zIndex = '-999';
                this.borderCanvas.style.pointerEvents = 'none';
                this.borderCanvas.style.opacity = '1.0';
                this.borderCanvas.width = window.innerWidth;
                this.borderCanvas.height = window.innerHeight;
                document.body.appendChild(this.borderCanvas);
            },

            // Find the actual Phaser canvas element
            findPhaserCanvas: function () {
                // Try multiple selectors to find the Phaser canvas
                const selectors = [
                    '#game-container canvas',
                    '.phaser-canvas',
                    'canvas[data-phaser="true"]',
                    '#game-container > canvas'
                ];

                for (const selector of selectors) {
                    const canvas = document.querySelector(selector);
                    if (canvas) {
                        console.log("Found Phaser canvas with selector:", selector);
                        return canvas;
                    }
                }

                // Fallback: find any canvas inside game-container
                const gameContainer = document.getElementById('game-container');
                if (gameContainer) {
                    const canvas = gameContainer.querySelector('canvas');
                    if (canvas) {
                        console.log("Found canvas in game-container");
                        return canvas;
                    }
                }

                console.warn("Could not find Phaser canvas");
                return null;
            },

            // Check letterboxing and determine which sides need borders
            getLetterboxingSides: function () {
                const phaserCanvas = this.findPhaserCanvas();
                if (!phaserCanvas) {
                    return { top: false, bottom: false, left: false, right: false };
                }

                const canvasRect = phaserCanvas.getBoundingClientRect();
                const viewportWidth = window.innerWidth;
                const viewportHeight = window.innerHeight;

                console.log("Canvas rect:", canvasRect);
                console.log("Viewport:", viewportWidth, "x", viewportHeight);

                const sides = {
                    left: canvasRect.left > 10,
                    right: (viewportWidth - canvasRect.right) > 10,
                    top: canvasRect.top > 10,
                    bottom: (viewportHeight - canvasRect.bottom) > 10
                };

                console.log("Letterboxing sides:", sides);
                return sides;
            },

            // Check if any letterboxing exists
            hasAnyLetterboxing: function () {
                const sides = this.getLetterboxingSides();
                return sides.left || sides.right || sides.top || sides.bottom;
            },

            // Update borders based on current layout
            updateBorders: function () {
                const letterboxingSides = this.getLetterboxingSides();
                const hasAnyBoxing = this.hasAnyLetterboxing();

                if (hasAnyBoxing) {
                    this.drawGameBorder(letterboxingSides);
                } else {
                    this.clearBorder();
                }
            },

            // Draw the L pattern
            drawPattern: function () {
                if (!this.patternCanvas) return;

                const ctx = this.patternCanvas.getContext('2d');
                ctx.clearRect(0, 0, this.patternCanvas.width, this.patternCanvas.height);
                ctx.fillStyle = this.config.color;

                // Calculate L dimensions with 3:2 ratio (standing up)
                const verticalHeight = this.config.size * 3;
                const horizontalWidth = this.config.size * 2;
                const thickness = this.config.thickness;

                // Interlocking pattern dimensions
                const overlapOffset = horizontalWidth * 0.6;
                const pairWidth = horizontalWidth * 1.6;
                const patternWidth = pairWidth + this.config.spacing;
                const verticalSpacing = verticalHeight + this.config.spacing;

                const numPatternsPerRow = Math.ceil(this.patternCanvas.width / patternWidth) + 2;
                const rows = Math.ceil(this.patternCanvas.height / verticalSpacing) + 1;

                for (let row = 0; row < rows; row++) {
                    // Calculate row offset
                    const rowOffset = (row % 2 === 1) ? patternWidth / 3 : 0;

                    // Create temporary canvas for this row to avoid opacity compounding
                    const tempCanvas = document.createElement('canvas');
                    tempCanvas.width = this.patternCanvas.width;
                    tempCanvas.height = verticalHeight;
                    const tempCtx = tempCanvas.getContext('2d');
                    tempCtx.fillStyle = this.config.color;

                    for (let patternIndex = 0; patternIndex < numPatternsPerRow; patternIndex++) {
                        const patternStartX = patternIndex * patternWidth - rowOffset;
                        const tempY = 0;

                        if (patternStartX > this.patternCanvas.width + patternWidth) continue;

                        // Normal L position
                        const normalLX = patternStartX;
                        // Inverted L position
                        const invertedLX = patternStartX + overlapOffset;

                        // Draw normal L on temp canvas
                        if (normalLX + horizontalWidth > 0 && normalLX < this.patternCanvas.width) {
                            tempCtx.fillRect(normalLX, tempY, thickness, verticalHeight);
                            tempCtx.fillRect(normalLX, tempY + verticalHeight - thickness, horizontalWidth, thickness);
                        }

                        // Draw inverted L on temp canvas
                        if (invertedLX + horizontalWidth > 0 && invertedLX < this.patternCanvas.width) {
                            tempCtx.fillRect(invertedLX, tempY, horizontalWidth, thickness);
                            tempCtx.fillRect(invertedLX + horizontalWidth - thickness, tempY, thickness, verticalHeight);
                        }
                    }

                    // Draw temp canvas to main canvas with row-based opacity
                    const y = row * verticalSpacing;
                    if (y <= this.patternCanvas.height) {
                        ctx.globalAlpha = (row % 2 === 0) ? 0.5 : 1.0;
                        ctx.drawImage(tempCanvas, 0, y);
                        ctx.globalAlpha = 1.0;
                    }
                }
            },

            // Draw border around game area only on needed sides
            drawGameBorder: function (sides) {
                const phaserCanvas = this.findPhaserCanvas();
                if (!phaserCanvas) return;

                const ctx = this.borderCanvas.getContext('2d');
                ctx.clearRect(0, 0, this.borderCanvas.width, this.borderCanvas.height);

                const canvasRect = phaserCanvas.getBoundingClientRect();
                const borderWidth = this.config.borderWidth;

                ctx.fillStyle = this.config.color;

                const x = canvasRect.left;
                const y = canvasRect.top;
                const width = canvasRect.width;
                const height = canvasRect.height;

                console.log("Drawing border around canvas at:", x, y, width, height);

                // Draw only the sides that have letterboxing
                if (sides.top) {
                    ctx.fillRect(x - borderWidth, y - borderWidth, width + (borderWidth * 2), borderWidth);
                }

                if (sides.bottom) {
                    ctx.fillRect(x - borderWidth, y + height, width + (borderWidth * 2), borderWidth);
                }

                if (sides.left) {
                    ctx.fillRect(x - borderWidth, y, borderWidth, height);
                }

                if (sides.right) {
                    ctx.fillRect(x + width, y, borderWidth, height);
                }

                console.log("Drew game border - letterboxing on sides:", sides);
            },

            // Clear the border canvas
            clearBorder: function () {
                if (!this.borderCanvas) return;
                const ctx = this.borderCanvas.getContext('2d');
                ctx.clearRect(0, 0, this.borderCanvas.width, this.borderCanvas.height);
            },

            // Handle window resize
            handleResize: function () {
                if (!this.patternCanvas || !this.borderCanvas) return;

                // Update canvas sizes
                this.patternCanvas.width = window.innerWidth;
                this.patternCanvas.height = window.innerHeight;
                this.borderCanvas.width = window.innerWidth;
                this.borderCanvas.height = window.innerHeight;

                // Redraw pattern
                this.drawPattern();

                // Update borders after a short delay to let layout settle
                setTimeout(() => {
                    this.updateBorders();
                }, 50);
            },

            // Set opacity (only affects pattern, not border)
            setOpacity: function (opacity) {
                this.config.opacity = Math.max(0, Math.min(1, opacity));
                if (this.patternCanvas) {
                    this.patternCanvas.style.opacity = this.config.opacity;
                }
            },

            // Clean up
            cleanup: function () {
                if (this.patternCanvas && this.patternCanvas.parentNode) {
                    this.patternCanvas.parentNode.removeChild(this.patternCanvas);
                }
                if (this.borderCanvas && this.borderCanvas.parentNode) {
                    this.borderCanvas.parentNode.removeChild(this.borderCanvas);
                }
                this.patternCanvas = null;
                this.borderCanvas = null;
                this.isInitialized = false;
                window.removeEventListener('resize', this.handleResize);

                console.log("L pattern background cleaned up");
            }
        };

        // Initialize the background system immediately after the game is created
        LPatternBackgroundSystem.init();
    </script>
</body>

</html>